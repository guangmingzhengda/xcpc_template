[TOC]

## 因数信息表

| n<=        | 1e3  | 1e4  | 1e5   | 1e6    | 1e7     |
| ---------- | ---- | ---- | ----- | ------ | ------- |
| 质因子数   | 4    | 5    | 6     | 7      | 8       |
| 因数个数   | 32   | 64   | 128   | 240    | 448     |
| 因数最多数 | 840  | 9240 | 83160 | 720720 | 8648640 |

| 1e8      | 1e9       | 1e10       | 1e11        |
| -------- | --------- | ---------- | ----------- |
| 8        | 9         | 10         | 10          |
| 768      | 1344      | 2304       | 4032        |
| 91891800 | 931170240 | 6983776800 | 97772875200 |

| 1e12         | 1e13          | 1e14           | 1e15            |
| ------------ | ------------- | -------------- | --------------- |
| 11           | 12            | 12             | 13              |
| 6720         | 10752         | 17280          | 26880           |
| 963761198400 | 9316358251200 | 97821761637600 | 866421317361600 |

| 1e16             | 1e17              | 1e18               |
| ---------------- | ----------------- | ------------------ |
| 13               | 14                | 15                 |
| 41472            | 64512             | 103680             |
| 9097423832296800 | 74801040398884800 | 897612484786617600 |

## 二进制相关函数

```cpp
__builtin_ctz(x) : 返回int类型二进制下末尾0的个数
__builtin_clz(x) : 返回int类型二进制下前导0的个数
__builtin_popcount(x) : 返回int类型二进制下1的个数
__builtin_ffs(x) : 返回int类型二进制下最后一个1是第几位（f(8)=4）
__builtin_sqrt(x) : 快速计算sqrt，大概是sqrt速度的10倍
```

## 其他函数

```cpp
memset(a,val,size) : 将每个字节赋为val（应为0~255的一个数），通常val为0x7f约为正无穷大，建议0x3f，这样加起来不会爆int/ll，0xff为-1，欲设置大小可用memset(a,0x3f,sizeof(int)*(n+1))
nth_element(a+1,a+k+1,a+n+1) : 将第k大的数放在第k位，前面的不超过它，后面的不小于它，复杂度约为O(n)
atoi(char*) : 将字符数组从左到右转化为int类型（可带+-号），atoll对应long long，atof对应float
cout<<fixed<<setprecision(x)<<y; : 保留x位小数输出
assert(逻辑表达式) : 不满足该条件会终止程序，并在控制台输出错误地点
迭代器遍历set
set<int>::iterator it=s.begin();
for(;it!=s.end();it++) cout<<*it<<" ";
set<int>::reverse_iterator it2=s.rend();
for(;it2!=s.rbegin();it2--)	cout<<*it2<<" ";
```

## 基础

### 归并排序

```cpp
long long n,ans,a[maxn],t[maxn];
void m_sort(int l,int r) {
	if(l==r) return ;
	int m=(l+r)/2;
	m_sort(l,m);m_sort(m+1,r);
	int p=l,i=l,j=m+1;
	while(i<=m&&j<=r) {
		if(a[i]>a[j]) {
			ans=ans+m-i+1;
			t[p++]=a[j++];
		}
		else t[p++]=a[i++];
	}
	while(i<=m) t[p++]=a[i++];
	while(j<=r) t[p++]=a[j++];
	for(int i=l;i<=r;i++) a[i]=t[i];
}
int main() {
	m_sort(1,n);
	cout<<ans<<endl;//逆序对 
	return 0;
}
```

## STL

### unordered_map

```cpp
struct custom_hash {
	static uint64_t splitmix64(uint64_t x) {
		x+=0x9e3779b97f4a7c15;
		x=(x^(x>>30))*0xbf58476d1ce4e5b9;
		x=(x^(x>>27))*0x94d049bb133111eb;
		return x^(x>>31);
	}
	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM=chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};
unordered_map<int, int, custom_hash> safe_map;

```



## 杂

### 计算时间

```cpp
	int begintime,endtime;
	begintime=clock();	//计时开始
	endtime = clock();	//计时结束
	printf("\n\nRunning Time：%dms\n", endtime-begintime);
```

### 离散化

```cpp
int n,a[maxn],b[maxn];
int main() {
	n=gint();
	for(int i=1;i<=n;i++) a[i]=b[i]=gint();
	sort(b+1,b+n+1);
	int nn=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++) a[i]=lower_bound(b+1,b+nn+1,a[i])-b;
	return 0;
}
```

### 扫描线

求矩形并面积

```cpp
#define maxn 300
using namespace std;
int lazy[maxn << 3];  // 标记了这条线段出现的次数
double s[maxn << 3];

struct node1 {
  double l, r;
  double sum;
} cl[maxn << 3];  // 线段树

struct node2 {
  double x, y1, y2;
  int flag;
} p[maxn << 3];  // 坐标

// 定义sort比较
bool cmp(node2 a, node2 b) { return a.x < b.x; }

// 上传
void pushup(int rt) {
  if (lazy[rt] > 0)
    cl[rt].sum = cl[rt].r - cl[rt].l;
  else
    cl[rt].sum = cl[rt * 2].sum + cl[rt * 2 + 1].sum;
}

// 建树
void build(int rt, int l, int r) {
  if (r - l > 1) {
    cl[rt].l = s[l];
    cl[rt].r = s[r];
    build(rt * 2, l, (l + r) / 2);
    build(rt * 2 + 1, (l + r) / 2, r);
    pushup(rt);
  } else {
    cl[rt].l = s[l];
    cl[rt].r = s[r];
    cl[rt].sum = 0;
  }
  return;
}

// 更新
void update(int rt, double y1, double y2, int flag) {
  if (cl[rt].l == y1 && cl[rt].r == y2) {
    lazy[rt] += flag;
    pushup(rt);
    return;
  } else {
    if (cl[rt * 2].r > y1) update(rt * 2, y1, min(cl[rt * 2].r, y2), flag);
    if (cl[rt * 2 + 1].l < y2)
      update(rt * 2 + 1, max(cl[rt * 2 + 1].l, y1), y2, flag);
    pushup(rt);
  }
}

int main() {
  int temp = 1, n;
  double x1, y1, x2, y2, ans;
  while (scanf("%d", &n) && n) {
    ans = 0;
    for (int i = 0; i < n; i++) {
      scanf("%lf %lf %lf %lf", &x1, &y1, &x2, &y2);
      p[i].x = x1;
      p[i].y1 = y1;
      p[i].y2 = y2;
      p[i].flag = 1;
      p[i + n].x = x2;
      p[i + n].y1 = y1;
      p[i + n].y2 = y2;
      p[i + n].flag = -1;
      s[i + 1] = y1;
      s[i + n + 1] = y2;
    }
    sort(s + 1, s + (2 * n + 1));  // 离散化
    sort(p, p + 2 * n, cmp);  // 把矩形的边的横坐标从小到大排序
    build(1, 1, 2 * n);       // 建树
    memset(lazy, 0, sizeof(lazy));
    update(1, p[0].y1, p[0].y2, p[0].flag);
    for (int i = 1; i < 2 * n; i++) {
      ans += (p[i].x - p[i - 1].x) * cl[1].sum;
      update(1, p[i].y1, p[i].y2, p[i].flag);
    }
    printf("Test case #%d\nTotal explored area: %.2lf\n\n", temp++, ans);
  }
  return 0;
}
```

### 三分

求极小值点

```cpp
const double eps=1e-10;
while (r - l > eps) {
  mid = (lmid + rmid) / 2;
  lmid = mid - eps;
  rmid = mid + eps;
  if (f(lmid) < f(rmid))
    r = mid;
  else
    l = mid;
}
```

### O(3)优化等

```cpp
#pragma GCC optimize(3,"Ofast","inline")
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
```

### 快读

```cpp
inline int gint() {//注意long long
	char ch=getchar();int s=0,f=1;
	while(!isdigit(ch)) {if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) {s=(s<<3)+(s<<1)+(ch^48);ch=getchar();}
	return s*f;
}
#define gc()(is==it?it=(is=in)+fread(in,1,Q,stdin),(is==it?EOF:*is++):*is++)
const int Q=(1<<24)+1;
char in[Q],*is=in,*it=in,c;
inline int gint() {
	int n=0,f=1;
	for(;(c=gc())<'0'||c>'9';) if(c=='-') f=-1;
	for(;c<='9'&&c>='0';c=gc()) n=(n<<1)+(n<<3)+(c^48);
	return n*f;
}
```

### 快输

```cpp
inline void Write(int x) {
    static int sta[15];
    if (x<0)    {putchar('-');    x=-x;}
      register int top=0;
      do{
        sta[top++]=x%10,x/=10;
      }while (x);
      while (top) putchar(sta[--top]+48);
}
```

### 快速取模

```cpp
struct fastmod {
    using u64 = uint64_t;
    using u128 = __uint128_t;
    int f, l; u64 m, d;
    fastmod(u64 d): d(d) {
        l = 64 - __builtin_clzll(d - 1);
        const u128 one = 1;
        u128 M = ((one << (64 + l)) + (one << l)) / d;
        if(M < (one << 64)) f = 1, m = M;
        else f = 0, m = M - (one << 64);
    }
    friend u64 operator/(u64 n, const fastmod &m) { // get n / d
        if (m.f) return u128(n) * m.m >> 64 >> m.l;
        else {
            u64 t = u128(n) * m.m >> 64;
            return (((n - t) >> 1) + t) >> (m.l - 1);
        }
    }
    friend u64 operator%(u64 n, const fastmod &m) { // get n % d
        return n - n / m * m.d;
    }
};

```

## 几何

### 总

```cpp
const double eps = 1e-8;	// 根据题目精度要求进行修改
const double PI = acos(-1.0);	// pai, 3.1415916....
int sgn(double x) {	// 进行判断, 提高精度
    if(fabs(x)<eps) return 0;	// x == 0, 精度范围内的近似相等
    return x>0?1:-1;			// 返回正负
}
struct Point {
    double x, y;
    Point(double x = 0, double y = 0) : x(x), y(y) {}  // 构造函数, 初始值为 0
    // 点 - 点 = 向量(向量AB = B - A)
    Point operator- (const Point &B) const { return Point(x - B.x, y - B.y); }
    // 点 + 点 = 点, 点 + 向量 = 向量, 向量 + 向量 = 向量
    Point operator+ (const Point &B) const { return Point(x + B.x, y + B.y); }
    // 向量 × 向量 (叉积)
    double operator^ (const Point &B) const { return x * B.y - y * B.x; }
    // 向量 · 向量 (点积)
    double operator* (const Point &B) const { return x * B.x + y * B.y; }
    // 点 * 数 = 点, 向量 * 数 = 向量
    Point operator* (const double &B) const { return Point(x * B, y * B); }
    // 点 / 数 = 点, 向量 / 数 = 向量
    Point operator/ (const double &B) const { return Point(x / B, y / B); }
    // 判断大小, 一般用于排序
    bool operator< (const Point &B) const { return x < B.x || (x == B.x && y < B.y); }
    // 判断相等, 点 == 点, 向量 == 向量, 一般用于判断和去重
    bool operator== (const Point &B) const { return sgn(x - B.x) == 0 && sgn(y - B.y) == 0; }
    // 判断不相等, 点 != 点, 向量 != 向量
    bool operator!= (const Point &B) const { return sgn(x - B.x) || sgn(y - B.y); }
} ;
double dist(Point a,Point b) {return sqrt((a-b)*(a-b));}
double len(Point A) {return sqrt(A*A);}
double Angle(Point A,Point B) {
    double t=acos((A*B)/len(A)/len(B));
    return t;               
}
struct Line {
    Point s,e;
    Line() {}
    Line(Point x, Point y):s(x),e(y) {}
};
int Cross(Point a,Point b,Point c) {return sgn((b-a)^(c-a));}
bool In_one_line(Point A,Point B,Point C) {return !sgn((B-A)^(C-B));}
bool OnSegment(Point P,Point A,Point B) {
    Point PA=A-P,PB=B-P;
    return sgn(PA^PB)==0&&sgn(PA*PB)<=0;	// <=, 包括端点; <, 不包括端点
}
double Dist_point_to_line(Point P,Point A,Point B) {//点到直线距离 
    Point v1=B-A,v2=P-A;
    return fabs((v1^v2)/len(v1));
}
double Dist_point_to_seg(Point P, Point A, Point B) {//点到线段距离 
    if(A==B) return len(P-A);		// 如果重合, 那么就是两点的距离
    Point v1=B-A,v2=P-A,v3=P-B;
    if(sgn(v1*v2)<0) return len(v2);	// AP 最短
    if(sgn(v1*v3)>0) return len(v3);	// BP 最短
    return fabs((v1^v2)/len(v1));		// 垂线
}
bool Intersect_line_seg(Point a,Point b,Point c,Point d) {//判断直线线段是否相交 
    return Cross(a,b,c)*Cross(a,b,d)<=0;
}
bool Intersect_seg(Point a,Point b,Point c,Point d) {
    if(OnSegment(a,c,d)||OnSegment(b,c,d)||OnSegment(c,a,b)||OnSegment(d,a,b)) return 1;
    if(Cross(a,b,c)*Cross(a,b,d)>=0) return 0;
    if(Cross(c,d,a)*Cross(c,d,b)>=0) return 0;
    return 1;
}
Point Intersection_line(Point a,Point b,Point c,Point d) {//直线交点 
    Point u=b-a,v=d-c;
    double t=((a-c)^v)/(v^u);
    return a+u*t;
}
double Area(Point a,Point b,Point c) {
	return fabs((c-a)^(b-a))/2.0;
}
```

### 重载点

```cpp
struct Point{
	double x,y;
	Point(){}
	Point(double x_,double y_) {x=x_;y=y_;}
	Point operator + (Point a) {return {x+a.x,y+a.y};}
	Point operator - (Point a) {return {x-a.x,y-a.y};}
	double operator ^ (Point a) {return x*a.y-y*a.x;}
	double operator * (Point a) {return x*a.x+y*a.y;}
} a[maxn],s[maxn];
```

### 凸包

点在a数组中，结果返回在s数组中 

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int n,top;
struct Point{
	double x,y;
	Point(){}
	Point(double x_,double y_) {x=x_;y=y_;}
	Point operator + (Point a) {return {x+a.x,y+a.y};}
	Point operator - (Point a) {return {x-a.x,y-a.y};}
	double operator ^ (Point a) {return x*a.y-y*a.x;}
} a[maxn],s[maxn];
inline double dis(Point c,Point d) {return sqrt((c.x-d.x)*(c.x-d.x)+(c.y-d.y)*(c.y-d.y));}
inline int cross(Point u1,Point u2,Point v1,Point v2) {
	return (u2.x-u1.x)*(v2.y-v1.y)-(u2.y-u1.y)*(v2.x-v1.x);
}
inline bool cmp(Point c,Point d) {
	if(cross(a[1],c,a[1],d)<0) return 0;
	if(cross(a[1],c,a[1],d)>0) return 1;
	return dis(a[1],c)<dis(a[1],d);
}
inline void work() {
	sort(a+2,a+n+1,cmp);
	s[++top]=a[1];
	for(int i=2;i<=n;i++) {
		while(top>1&&cross(s[top-1],s[top],s[top],a[i])<=0) top--;
		s[++top]=a[i];
	}
	s[top+1]=a[1];
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) {
        scanf("%lf%lf",&a[i].x,&a[i].y);
		if(i!=1&&a[i].y<a[1].y) swap(a[1],a[i]);//p1为左下角的点 
    }
	work();
	return 0;
}
```

### 旋转卡壳求最大直径

点在a数组中

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int n,top;
struct Point{
	double x,y;
	Point(){}
	Point(double x_,double y_) {x=x_;y=y_;}
	Point operator + (Point a) {return {x+a.x,y+a.y};}
	Point operator - (Point a) {return {x-a.x,y-a.y};}
	double operator ^ (Point a) {return x*a.y-y*a.x;}
	double operator * (Point a) {return x*a.x+y*a.y;}
} a[maxn],s[maxn];
inline int cross(Point u1,Point u2,Point v1,Point v2) {
	return (u2.x-u1.x)*(v2.y-v1.y)-(u2.y-u1.y)*(v2.x-v1.x);
}
inline double dis(Point u,Point v) {
	return (u-v)*(u-v);
}
inline bool cmp(Point c,Point d) {
	if(((c-a[1])^(d-a[1]))<0) return 0;
	if(((c-a[1])^(d-a[1]))>0) return 1;
	return dis(a[1],c)<dis(a[1],d);
}
inline void work() {
	sort(a+2,a+n+1,cmp);
	s[++top]=a[1];
	for(int i=2;i<=n;i++) {
		//新点在原来右侧或共线,则top点不能保留 
		while(top>1&&cross(s[top-1],s[top],s[top],a[i])<=0) top--;
		s[++top]=a[i];
	}
	s[top+1]=a[1];//为了构成一圈,calc时计算方便 
}
inline double calc() {
	if(top==1) return 0;
	if(top==2) return dis(s[1],s[2]);
	int v=2;double ans=0;
	for(int u=1;u<=top;u++) {
		while(cross(s[u],s[u+1],s[u+1],s[v])<=cross(s[u],s[u+1],s[u+1],s[v+1]))
			v=v==top?1:v+1;
		ans=max(ans,max(dis(s[u],s[v]),dis(s[u+1],s[v])));
	}
	return ans;
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) {
		scanf("%lf%lf",&a[i].x,&a[i].y);
		if(a[i].y<a[1].y||(a[i].y==a[1].y&&a[i].x<a[1].x)) swap(a[1],a[i]);
	}
	work();
	printf("%lf\n",calc());
	return 0;
} 
```

### 平面最近点对（分治）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+10;
const double INF=1e20;
int n;
struct Point{
	double x,y;
} a[maxn],b[maxn];
inline bool cmp1(const Point &c,const Point &d) {
	return c.x==d.x?c.y<d.y:c.x<d.x;
}
inline bool cmp2(const Point &c,const Point &d) {
	return c.y<d.y;
}
inline double dis(Point c,Point d) {
	return sqrt((c.x-d.x)*(c.x-d.x)+(c.y-d.y)*(c.y-d.y));
}
inline double solve(int l,int r) {
	if(l==r) return INF;
	if(l+1==r) return dis(a[l],a[r]);
	int mid=(l+r)>>1;
	double d=min(solve(l,mid),solve(mid+1,r));
	int k=0;
	//选出来横坐标距中心<d的点,这个循环次数为区间长度,结合分治,应该为nlogn 
	for(int i=l;i<=r;i++) if(fabs(a[i].x-a[mid].x)<d) b[++k]=a[i];
	stable_sort(b+1,b+k+1,cmp2);
	for(int i=1;i<=k;i++) {
		//在2d*d的这个矩形中,除了b[i]至多有4个点,所以次数最多为4k,复杂度必为nlogn 
		for(int j=i+1;j<=k&&b[j].y-b[i].y<d;j++) {
			d=min(d,dis(b[i],b[j]));
		}
	}
	return d;
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%lf%lf",&a[i].x,&a[i].y);
	stable_sort(a+1,a+n+1,cmp1);
	printf("%.4lf",solve(1,n));
	return 0;
}
```

### 三点确定外接圆圆心

```cpp
struct Point {
    double x,y;
    Point(double x = 0, double y = 0):x(x),y(y){}
};
Point Excenter(Point a, Point b, Point c){
    double a1 = b.x - a.x;
    double b1 = b.y - a.y;
    double c1 = (a1*a1 + b1*b1)/2;
    double a2 = c.x - a.x;
    double b2 = c.y - a.y;
    double c2 = (a2*a2 + b2*b2)/2;
    double d = a1*b2 - a2*b1;
    return Point(a.x + (c1*b2 - c2*b1)/d, a.y + (a1*c2 - a2*c1)/d);
}

```

### 半平面交

返回L数组中为平面交点构成的凸包

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
const double eps=1e-10;
int T,n;
struct Point{
	double x,y;
	Point(){}
	Point(double x_,double y_) {x=x_;y=y_;}
	Point operator + (Point a) {return {x+a.x,y+a.y};}
	Point operator - (Point a) {return {x-a.x,y-a.y};}
	double operator ^ (Point a) {return x*a.y-y*a.x;}
} p[maxn];
struct Line{
	Point s,e;
	Line() {}
	Line(Point a,Point b) {s=a;e=b;}
};
Line L[maxn],q[maxn];
double Get_p_angle(Point a) {
	return atan2(a.y,a.x);
}
double Get_l_angle(Line a) {
	return atan2(a.e.y-a.s.y,a.e.x-a.s.x);
}
//按极角排序,极角相同时左边在后 
bool cmp(Line a,Line b) {
	Point va=a.e-a.s,vb=b.e-b.s;
	double A=Get_p_angle(va),B=Get_p_angle(vb);
	if(fabs(A-B)<eps) return ((va)^(b.e-a.s))>=0;
	return A<B;
}
Point Get_point(Line a,Line b) {
	double a1=a.s.y-a.e.y,b1=a.e.x-a.s.x,c1=a.s.x*a.e.y-a.e.x*a.s.y;
	double a2=b.s.y-b.e.y,b2=b.e.x-b.s.x,c2=b.s.x*b.e.y-b.e.x*b.s.y;
	return Point((c1*b2-c2*b1)/(a2*b1-a1*b2),(a2*c1-a1*c2)/(a1*b2-a2*b1));
}
//判断b,c交点是否在a的右边 
bool On_right(Line a,Line b,Line c) {
	Point o=Get_point(b,c);
	if(((a.e-a.s)^(o-a.s))<0) return 1;
	return 0;
}
bool work() {
	sort(L,L+n,cmp);
	int head=0,tail=0,cnt=0;
	for(int i=0;i<n-1;i++) {
		if(fabs(Get_l_angle(L[i])-Get_l_angle(L[i+1]))<eps) continue;
		L[cnt++]=L[i];
	}
	L[cnt++]=L[n-1];
	for(int i=0;i<cnt;i++) {
		while(tail-head>1&&On_right(L[i],q[tail-1],q[tail-2])) tail--;
		while(tail-head>1&&On_right(L[i],q[head],q[head+1])) head++;
		q[tail++]=L[i];
	}
	while(tail-head>1&&On_right(q[head],q[tail-1],q[tail-2])) tail--;
	while(tail-head>1&&On_right(q[tail-1],q[head],q[head+1])) head++;
//	if(tail-head<3) ok=0;els ok=1;
}
bool judge() {
	double ans=0;
	for(int i=1;i<n-1;i++) 
		ans+=((p[i]-p[0])^(p[i+1]-p[0]));
	return ans<0;
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%lf%lf",&p[i].x,&p[i].y);
	for(int i=1;i<=n;i++) L[i]=Line(p[i],p[i%n+1]);//默认点逆时针排布 
	return 0;
}
```

### 最小圆覆盖

返回圆心坐标和半径

```c++
圆 C;
for(i=1 to n)
{
	if(P[i] 不在 C 内)
	{
		C = {P[i], 0};
		for(j=1 to i-1)
		{
        	if(P[j] 不在 C 内)
			{
				C = {0.5*(P[i]+P[j]), 0.5*dist(P[i], P[j])};
				for(k=1 to j-1)
				{
					if(P[k] 不在 C 内)
					{
						C = 外接圆(P[i], P[j], P[k]);
					}
				}
			}
		}
	}
}
```

```cpp
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>

using namespace std;

int n;
double r;

struct point {
  double x, y;
} p[100005], o;

double sqr(double x) { return x * x; }

double dis(point a, point b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y)); }

bool cmp(double a, double b) { return fabs(a - b) < 1e-8; }

point geto(point a, point b, point c) {
  double a1, a2, b1, b2, c1, c2;
  point ans;
  a1 = 2 * (b.x - a.x), b1 = 2 * (b.y - a.y),
  c1 = sqr(b.x) - sqr(a.x) + sqr(b.y) - sqr(a.y);
  a2 = 2 * (c.x - a.x), b2 = 2 * (c.y - a.y),
  c2 = sqr(c.x) - sqr(a.x) + sqr(c.y) - sqr(a.y);
  if (cmp(a1, 0)) {
    ans.y = c1 / b1;
    ans.x = (c2 - ans.y * b2) / a2;
  } else if (cmp(b1, 0)) {
    ans.x = c1 / a1;
    ans.y = (c2 - ans.x * a2) / b2;
  } else {
    ans.x = (c2 * b1 - c1 * b2) / (a2 * b1 - a1 * b2);
    ans.y = (c2 * a1 - c1 * a2) / (b2 * a1 - b1 * a2);
  }
  return ans;
}

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++) scanf("%lf%lf", &p[i].x, &p[i].y);
  for (int i = 1; i <= n; i++) swap(p[rand() % n + 1], p[rand() % n + 1]);
  o = p[1];
  for (int i = 1; i <= n; i++) {
    if (dis(o, p[i]) < r || cmp(dis(o, p[i]), r)) continue;
    o.x = (p[i].x + p[1].x) / 2;
    o.y = (p[i].y + p[1].y) / 2;
    r = dis(p[i], p[1]) / 2;
    for (int j = 2; j < i; j++) {
      if (dis(o, p[j]) < r || cmp(dis(o, p[j]), r)) continue;
      o.x = (p[i].x + p[j].x) / 2;
      o.y = (p[i].y + p[j].y) / 2;
      r = dis(p[i], p[j]) / 2;
      for (int k = 1; k < j; k++) {
        if (dis(o, p[k]) < r || cmp(dis(o, p[k]), r)) continue;
        o = geto(p[i], p[j], p[k]);
        r = dis(o, p[i]);
      }
    }
  }
  printf("%.10lf\n%.10lf %.10lf", r, o.x, o.y);
  return 0;
}
```

### 圆的面积并

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1005;
const int INF = 1e9;
const double eps = 1e-8;
template <typename T> void chkmax(T &x, T y) {x = max(x, y); }
template <typename T> void chkmin(T &x, T y) {x = min(x, y); } 
template <typename T> void read(T &x) {
	x = 0; int f = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') f = -f;
	for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
	x *= f;
}
template <typename T> void write(T x) {
	if (x < 0) x = -x, putchar('-');
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
template <typename T> void writeln(T x) {
	write(x);
	puts("");
}
struct circle {int x, y, r; };
struct info {double x; bool type; };
int n, m;
bool del[MAXN];
circle a[MAXN], b[MAXN];
bool cmp(info a, info b) {return a.x < b.x; }
double f(double pos) {
	double ans = 0;
	int tot = 0; info tmp[MAXN * 2];
	for (int i = 1; i <= n; i++) {
		double d = a[i].r * a[i].r - (a[i].x - pos) * (a[i].x - pos);
		if (fabs(d) <= eps) continue;
		d = sqrt(d);
		tmp[++tot] = (info) {a[i].y - d, true};
		tmp[++tot] = (info) {a[i].y + d, false};
	}
	sort(tmp + 1, tmp + tot + 1, cmp);
	int cnt = 0; double last = 0;
	for (int i = 1; i <= tot; i++) {
		if (tmp[i].type) {
			if (++cnt == 1) last = tmp[i].x;
		} else if (--cnt == 0) ans += tmp[i].x - last;
	}
	return ans;
}
double inter(double l, double r) {
	double mid = (l + r) / 2;
	return (f(l) + 4 * f(mid) + f(r)) / 6 * (r - l);
}
double calc(double l, double r, double now) {
	double mid = (l + r) / 2;
	double nowl = inter(l, mid);
	double nowr = inter(mid, r);
	if (fabs(now - nowl - nowr) <= eps) return now;
	else return calc(l, mid, nowl) + calc(mid, r, nowr);
}
int main() {
	read(n);
	for (int i = 1; i <= n; i++)
		read(a[i].x), read(a[i].y), read(a[i].r);
	int Min = INF, Max = -INF;
	for (int i = 1; i <= n; i++) {
		chkmin(Min, a[i].x - a[i].r);
		chkmax(Max, a[i].x + a[i].r);
		if (del[i]) continue;
		for (int j = 1; j <= n; j++)
			if (j != i && !del[j] && a[j].r >= a[i].r && (a[j].r - a[i].r) * (a[j].r - a[i].r) >= (a[i].x - a[j].x) * (a[i].x - a[j].x) + (a[i].y - a[j].y) * (a[i].y - a[j].y)) {
				del[i] = true;
				break;
			}
	}
	m = 0;
	for (int i = 1; i <= n; i++)
		if (!del[i]) b[++m] = a[i];
	double ans = 0;
	for (int i = Min; i < Max; i++) {
		n = 0;
		for (int j = 1; j <= m; j++)
			if (i >= b[j].x - b[j].r && i < b[j].x + b[j].r) a[++n] = b[j];
		ans += calc(i, i + 1, inter(i, i + 1));
	}
	printf("%.3lf\n", ans);
	return 0;
}
```

## 数学

### 奇怪的东西

```cpp
namespace math
{
	int inv[N], fac[N], ifac[N];
	int mu[N], isprime[N], p[N];
	inline int qpow(int n,int k)
	{
		int ans = 1,base = n;
		while(k)
		{
			if(k & 1)
			ans = 1ll * ans * base % mod;
			base = 1ll * base * base % mod;
			k >>= 1;
		}
		return ans;
	}
	inline void fmod(int &x)
	{
		x -= mod;
		x += x >> 31 & mod;
	}
	void initmath(const int &n = N - 1)
	{
		inv[1] = 1,fac[0] = 1,fac[1] = 1;
		for(int i = 2;i <= n;i++)
		{
			fac[i] = 1ll * i * fac[i - 1] % mod;
			inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod;
		}
		ifac[n] = qpow(fac[n],mod - 2);
		for(int i = n - 1;i >= 0;i--)
		ifac[i] = 1ll * (i + 1) * ifac[i + 1] % mod;
	}
	void getmu(const int &n = N - 1) {
		int tot = 0;
		mu[1] = 1;
		for(int i = 2; i <= n; i++) {
			if(!isprime[i]) {
				mu[i] = -1, p[++tot] = i;
			}
			for(int j = 1; j <= tot && i * p[j] <= n; j++) {
				isprime[i * p[j]] = 1;
				if(i % p[j] == 0) {
					mu[i * p[j]] = 0;
					break;
				}
				mu[i * p[j]] = -mu[i];
			}
		}
	}
}
```



### 快速乘

返回 $x\times y \mod p$ 的值，要求 $2p\le MAX\_VAL$

```cpp
inline ll ksc(ll x,ll y,ll p){
	ll res=0;
	while(y){
		if(y&1)res=(res+x)%p;
		x=(x<<1)%p; y>>=1;
	}return res;
}
```

### exgcd

调用 `Exgcd(a,b,x,y)` ，答案即返回到 `x,y` 中

```cpp
ll Exgcd(ll a, ll b, ll &x, ll &y) {//ax+by=gcd(a,b)
  if (!b) {
    x = 1;
    y = 0;
    return a;
  }
  ll d = Exgcd(b, a % b, x, y);
  ll t = x;
  x = y;
  y = t - (a / b) * y;
  return d;
}
```

### CRT

求满足 $x\equiv a_i \mod b_i$ 的 $x$ ，其中 $b_i$ 为质数，复杂度 $O(n\log w)$ 

```cpp
//CRT板子: 
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,ans,a[11],b[11],t[11],m[11]={1};
//ti:mi在模bi意义下的数论倒数 
//x=ai(mod bi)(i:1~n)
//设m0=连乘(bi),mi=m0/bi (i:1~n)
//ans=求和(ai*ti*mi0)  (i:1~n) 
ll x,y,tx;
inline void exgcd(ll a,ll b) {//mi*ti=1(mod bi)==>ax=1(mod b) 
    if(b==0) {x=1;y=0;return ;}
    exgcd(b,a%b);
    tx=x;x=y;y=tx-int(a/b)*y;
}
ll ksc(ll a,ll b,ll mod){//快速乘 
    ll ans=0;
    for(;b;b>>=1,a=(a<<1)%mod) if(b&1) ans=(ans+a)%mod;
    return ans;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>b[i],cin>>a[i],m[0]*=b[i];
    for(int i=1;i<=n;i++) m[i]=m[0]/b[i],
        exgcd(m[i],b[i]),t[i]=(x%b[i]+b[i])%b[i],//求mi在模bi意义下的数论倒数 
        ans+=ksc(ksc(a[i],m[i],m[0]),t[i],m[0]),ans%=m[0];
    cout<<ans;
    return 0;
}
```

### EXCRT

在这里不保证 $b_i$ 为质数，复杂度同样为 $O(n\log w)$

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,mod,a[100010],b[100010],ans[100010];
//mod:lcm(a[i]),前i个方程中a的最小公倍数 
//ans[i]:前i个方程的最小正整数解,通解为ans[i]+k*mod,k为整数 
inline ll mul(ll c,ll d,ll mod)//龟速乘 
{
    ll sum=0;
    while(d){if(d&1) sum=(sum+c)%mod;d>>=1;c=(c+c)%mod;}
    return sum;
}
ll x,y,tx;//exgcd相关变量 
inline ll exgcd(ll a,ll b) {
    if(!b) {x=1;y=0;return a;}
    ll tgcd=exgcd(b,a%b);
    tx=x;x=y;y=tx-(ll)(a/b)*y;
    return tgcd;
}
//x0为前i-1个方程的解 
//x0+x*mod=bi (mod ai)
//x*mod=bi-x0 (mod ai)
//有解的充要条件:gcd(ai,mod)|(bi-x0)下文的B 
//解exgcd(mod,a[i]) 得x满足:x*mod=gcd (mod ai)
//令x=x*(bi-x0)/gcd即可 
int main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;i++) scanf("%lld%lld",&a[i],&b[i]);
    ans[1]=b[1]%a[1];mod=a[1];
    for(int i=2;i<=n;i++) {
        ll B=((b[i]-ans[i-1])%a[i]+a[i])%a[i];//保证非负 
        ll gcd=exgcd(mod,a[i]);
        x=mul(x,B/gcd,a[i]);//龟速乘 
//		if(B%gcd){puts("No Solution!");return 0;}//特判无解 
        ans[i]=ans[i-1]+x*mod;//解得答案 
        mod=mod/gcd*a[i];//更新mod 
        ans[i]=(ans[i]%mod+mod)%mod;//防止答案为负 
	}
    printf("%lld",ans[n]);
    return 0;
}
```

### 类欧几里得

* 引入

令$$f(a,b,c,n)=\sum_{i=0}^{n}\left \lfloor \frac{ai+b}{c}  \right \rfloor  $$
其中 $a,b,c,n$ 都是定值，考虑在 $O(logn)$ 的时间复杂度计算该式。

* 解释

当 $a\ge c$ 或者 $b \ge c$ 时，设$a=c\cdot k_{1} +a_{1}, b=c\cdot k_{2} +b_{1}(0 \leq a_1,b_1 <c)$ 我们可以将式子化为 $$\begin{align}
f(a,b,c,n) & = \sum_{i = 0}^{n}\left \lfloor \frac{(c\cdot k_1+a_1)\cdot i+c\cdot k_{2} +b_{1}}{c}  \right \rfloor\\ 
& =\frac{n(n+1)}{2}k_1+ (n+1)k_2+\sum_{i=0}^{n}\left \lfloor \frac{a_1\cdot i+b_1}{c}  \right \rfloor  \\
& =\frac{n(n+1)}{2}k_1+ (n+1)k_2+f(a_1,b_1,c,n) 
\end{align}$$
可知此时有 $a_1 <c, b_1<c$ ，考虑计算每一项的贡献，我们有：$$\begin{align}
f(a_1,b_1,c,n) & = \sum_{i = 0}^{n}\sum_{j=0}^{\left \lfloor \frac{a_1\cdot i+b_1}{c}  \right \rfloor-1 }1\\
& =\sum_{i = 0}^{\left \lfloor \frac{a_1n+b_1}{c}  \right \rfloor -1}  \sum_{j=0}^{n}\left [ i<\left \lfloor \frac{a_1\cdot j+b_1}{c}  \right \rfloor   \right ]  
\end{align}$$ 化简一下条件限制 $i<\left \lfloor \frac{a_1\cdot j+b_1}{c}  \right \rfloor\Longleftrightarrow i+1 \le \frac{a_1\cdot j+b_1}{c} \Longleftrightarrow a_1\cdot j+b_1\ge c(i+1)$ ，可以得到 $j$ 的取值范围为 $j>\frac{c\cdot i+c-b_1-1}{a_1}$ ，令 $m=\left \lfloor \frac{a_1n+b_1}{c}  \right \rfloor$ ，则有： $$\begin{align}
f(a_1,b_1,c,n) & = \sum_{i = 0}^{m-1}(n-\left \lfloor \frac{c\cdot i+c-b_1-1}{a_1} \right \rfloor )\\
& =nm - f(c,c-b_1-1,a_1,m-1) 
\end{align}$$ 可以看到 $a,c$ 在分子分母上交换了顺序，取模之后递归就类似于辗转相除的过程。



### LUCAS

$C_{n+m}^m\mod p$，复杂度$\log_pn*\log_2p$ 

$Lucas(n,m,p)=C(n\%p,m\%p)Lucas(\frac{n}{p},\frac{m}{p},p)$ 

```cpp
#include<iostream>
using namespace std;
ll p;
ll qp(ll base,ll p) {
	ll res=1;
	while(p) {
		if(p&1) res=res*base%mod;
		base=base*base%mod;p>>=1;
	}
	return res;
}
ll C(ll a,ll b) {
	if(b > a)
	return 0;
	ll ans = 1;
	for(int i = 1;i <= b;i++) {
		ll m = i % p;
		ll n = (a + i - b) % p;
		ans = ans * (qp(m,p - 2) * n % p) % p;
	}
	return ans;
}
ll lucas(ll a,ll b) {
	if(b == 0) return 1;
	return lucas(a / p,b / p) * C(a % p,b % p) % p;
}
int main() {
	ll n,m,t;
	cin >> t;
	for(int i = 1;i <= t;i++) {
		cin >> n >> m >> p;
		cout << lucas(n + m,n) << endl;
	}
	return 0;
}
```

### BSGS

求满足 $x^a\equiv b\mod p$ 的 $x$ ，复杂度 $O(\sqrt p)$

```cpp
#include<iostream>
#include<cmath>
#include<map>
using namespace std;
long long bsgs(long long a,long long b,long long p)
{
	map<long long,long long> x;
	long long base = 1,t = sqrt(p) + 1;
	for(int i = 1;i <= t;i++)
	{
		base = base * a % p;
		x[base * b % p] = i;
	}
	long long now = base;
	for(int i = 1;i <= t;i++)
	{
		if(x[now] != 0)
		return i * t - x[now];
		now = now * base % p;
	}
	return -1;
}
int main()
{
	long long p,a,b;
	cin >> p >> a >> b;
	if(a % p == 0 && b % p != 0)
		cout << "no solution";
	else if(a % p == 0 && b % p == 0)
		cout << 1;
	else if(bsgs(a,b,p) != -1)
		cout << bsgs(a,b,p);
	else
		cout << "no solution";
	return 0;
}
```

### 线性筛

```cpp
#include<bits/stdc++.h>
using namespace std;
bool vis[maxn]; 
int n,cnt,p[maxn];
void pre(int n) {
    for(int i=2;i<=n;i++) {
        if(!vis[i]) p[++cnt]=i;
        for(int j=1;j<=cnt&&i*p[j]<=n;j++) {
            vis[i*p[j]]=1;
            if(i%p[j]==0) break;
        }
    }
}
int main() {
    scanf("%d",&n);
	pre(n);
	return 0;
}
```

### 线性求欧拉函数

```cpp
int n,cnt,p[maxn],phi[maxn];
bool is_p[maxn];
void pre(int n) {
  for (int i = 1; i <= n; i++) {
    is_p[i] = 1;
  }
  int cnt = 0;
  is_p[1] = 0;
  phi[1] = 1;
  for (int i = 2; i <= n; i++) {
    if (is_p[i]) {
      p[++cnt] = i;
      phi[i] = i - 1;
    }
    for (int j = 1; j <= cnt && i * p[j] <= n; j++) {
      is_p[i * p[j]] = 0;
      if (i % p[j])
        phi[i * p[j]] = phi[i] * phi[p[j]];
      else {
        phi[i * p[j]] = phi[i] * p[j];
        break;
      }
    }
  }
}
```

### 最多因子数

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6+10;
const int INF=0x3f3f3f3f;
const ll LINF=0x3f3f3f3f3f3f3f3f;
const int MOD=1e9+7;
ll n,ans;
int prime[20] = {0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53};//1--16
ll tmp=0;
void dfs(ll m,ll res,int i,int limit){
	if(res>ans) ans=res,tmp=m;
//  ans=max(ans,res);
//	tmp=max(tmp,m);
    ll cnt=1;
    for(int j=1;j<=limit;j++) {
        cnt++;
        if(n/m<prime[i]) break;
        m*=prime[i];
        if(m<=n)
            dfs(m,res*cnt,i+1,j);
    }
}
int main() {
    scanf("%lld",&n);
    ans=0;
    dfs(1,1,1,61);
	printf("%lld\n",ans);
    printf("%lld\n",tmp);
	return 0;
}
```

### 整除分块

每次的 $i\in l\sim r$ 对应的 $\lfloor\frac ni\rfloor$ 均相同，本例求解 $\Sigma \lfloor\frac ni\rfloor$

```cpp
ll division_block(ll n){
    ll res=0;
    for(ll l=1,r;l<=n;l=r+1) {
        r=n/(n/l);
        res+=n/l*(r-l+1);
    }
    return res;
}
```

### Pollard-rho

$O(n^{1/4})$ 求最大质因数，其中包含 `Miller_Rabin` $O(1)$ 判断一个数是否为质数

```cpp
#include <bitsdc++.h>

using namespace std;

typedef long long ll;

int t;
long long max_factor, n;

long long gcd(long long a, long long b) {
  if (b == 0) return a;
  return gcd(b, a % b);
}

long long quick_pow(long long x, long long p, long long mod) {  // 快速幂
  long long ans = 1;
  while (p) {
    if (p & 1) ans = (__int128)ans * x % mod;
    x = (__int128)x * x % mod;
    p >>= 1;
  }
  return ans;
}

bool Miller_Rabin(long long p) {  // 判断素数
  if (p < 2) return 0;
  if (p == 2) return 1;
  if (p == 3) return 1;
  long long d = p - 1, r = 0;
  while (!(d & 1)) ++r, d >>= 1;  // 将d处理为奇数
  for (long long k = 0; k < 10; ++k) {
    long long a = rand() % (p - 2) + 2;
    long long x = quick_pow(a, d, p);
    if (x == 1 || x == p - 1) continue;
    for (int i = 0; i < r - 1; ++i) {
      x = (__int128)x * x % p;
      if (x == p - 1) break;
    }
    if (x != p - 1) return 0;
  }
  return 1;
}

long long Pollard_Rho(long long x) {
  long long s = 0, t = 0;
  long long c = (long long)rand() % (x - 1) + 1;
  int step = 0, goal = 1;
  long long val = 1;
  for (goal = 1;; goal *= 2, s = t, val = 1) {  // 倍增优化
    for (step = 1; step <= goal; ++step) {
      t = ((__int128)t * t + c) % x;
      val = (__int128)val * abs(t - s) % x;
      if ((step % 127) == 0) {
        long long d = gcd(val, x);
        if (d > 1) return d;
      }
    }
    long long d = gcd(val, x);
    if (d > 1) return d;
  }
}

void fac(long long x) {
  if (x <= max_factor || x < 2) return;
  if (Miller_Rabin(x)) {              // 如果x为质数
    max_factor = max(max_factor, x);  // 更新答案
    return;
  }
  long long p = x;
  while (p >= x) p = Pollard_Rho(x);  // 使用该算法
  while ((x % p) == 0) x /= p;
  fac(x), fac(p);  // 继续向下分解x和p
}

int main() {
  scanf("%d", &t);
  while (t--) {
    srand((unsigned)time(NULL));
    max_factor = 0;
    scanf("%lld", &n);
    fac(n);
    if (max_factor == n)  // 最大的质因数即自己
      printf("Prime\n");
    else
      printf("%lld\n", max_factor);
  }
  return 0;
}

```

### 矩阵快速幂

已重载 `*` ，包含矩阵初始化为单位阵

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll; 
const int maxn=110,mod=1e9+7;
int n;
ll k;
struct Matirix{
	int n,m;
	ll a[maxn][maxn];
	Matirix() {memset(a,0,sizeof a);}
	inline void init() {for(int i=1;i<=n;++i) a[i][i]=1;}
	inline void show() {
		for(int i=1;i<=n;i++) {
			for(int j=1;j<=m;j++)
				printf("%lld ",a[i][j]);
			puts("");
		}
	}
} ;
inline Matirix operator * (const Matirix &x,const Matirix &y) {
	Matirix z;z.n=x.n;z.m=y.m;
	for(int k=1;k<=x.m;k++) for(int i=1;i<=x.n;i++) for(int j=1;j<=y.m;j++)
		z.a[i][j]=(z.a[i][j]+x.a[i][k]*y.a[k][j]%mod)%mod;
	return z;
}
int main(){
	scanf("%d%lld",&n,&k);
	Matirix base;base.n=base.m=n;
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) scanf("%lld",&base.a[i][j]);
	Matirix ans;ans.n=ans.m=n;
	ans.init();
	while(k) {
		if(k&1) ans=ans*base;
		base=base*base;k>>=1;
	}
	ans.show();
	return 0;
}
```

### 高斯消元

输入一个$n\times (n+1)$的矩阵，返回唯一解，无穷多和无解都返回`No Solution` （支持的精度并不高）

```cpp
#include<bits/stdc++.h>
#define rint register int
using namespace std;
int n;
double maxn,eps=1E-8,a[110][110];
int main()
{
    scanf("%d",&n);
    for(rint i=1;i<=n;i++) for(rint j=1;j<=n+1;j++) scanf("%lf",&a[i][j]);
    for(rint i=1;i<=n;i++) {//处理第i个方程,第i个未知数 
        int p=i;maxn=0;//选择一个当前位置系数绝对值最大的调换过来,减小误差 
        for(rint j=i;j<=n;j++) if(fabs(a[j][i]-a[p][i])>maxn) p=j,maxn=fabs(a[j][i]-a[p][i]);
        for(rint j=1;j<=n+1;j++) swap(a[i][j],a[p][j]);
        if(fabs(a[i][i])<=eps) {//如果最大系数等于零,则有0*x=a,一定无解 
            printf("No Solution\n");
            return 0;
        }
        //将第i个方程第i个未知数前系数化为1,则需各项除a[i][i] 
        for(rint j=i+1;j<=n+1;j++) a[i][j]/=a[i][i];//a[i][i]/=a[i][i],可不写 
        for(rint j=1;j<=n;j++) if(i!=j) for(rint k=i+1;k<=n+1;k++)
			a[j][k]-=a[j][i]*a[i][k];//用加减法消去第j方程第i个未知数 
    }
    for(rint i=1;i<=n;i++) printf("%.2lf\n",a[i][n+1]);
    return 0;
}
```

### 行列式*

```cpp
#include<bits/stdc++.h>
#define INL inline
#define ll long long 
using namespace std;
const int N=605;
int n,a[N][N],MOD;
INL int read()
{
	int x=0,w=1;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')w=-1,ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+ch-48,ch=getchar();
	return x*w;
}
INL int sol()
{
	int res=1,w=1;
	for(int i=1;i<=n;i++)
	{ 
		for(int j=i+1;j<=n;++j)
		{
    		while(a[i][i])
			{
     	    	int div=a[j][i]/a[i][i];
        		for(int k=i;k<=n;++k)
				{
        		    a[j][k]=(a[j][k]-1ll*div*a[i][k]%MOD+MOD)%MOD;
        		}
        		swap(a[i],a[j]);w=-w;
    		}//对第 i 行和第 j 行做辗转相减。	
    		swap(a[i],a[j]);w=-w;
		}
	}
	for(int i=1;i<=n;i++)res=1ll*a[i][i]*res%MOD;
	res=1ll*w*res;
	return (res%MOD+MOD)%MOD;//经 典 模 加 模
}
int main()
{
	n=read(),MOD=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			a[i][j]=read();
	int ans=sol();printf("%d\n",ans);
	return 0;
}
```

### 线性基

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n;
ll x,a[55];//a[i]:二进制下最高位为i的数(a[i]< (1<<(i+1)) )
inline void ins(ll x) {
    for(int i=52;~i;i--) if(x&(1ll<<i)) {
        if(!a[i]) {a[i]=x;return;}//无数则直接插入 
        else x^=a[i];//保证x能被线性基中的数表示 
    }
}
inline ll qmax() {
	ll res=0; 
    for(int i=52;~i;i--) res=max(res,res^a[i]);
    return res;
}
int main() {
	scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%lld",&x),ins(x);
    printf("%lld\n",qmax());
    return 0;
}
```

### 矩阵求逆

$O(N^3)$ 求取模意义下的逆

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define re register
#define il inline
#define ll long long
using namespace std;

il ll read(){
    ll s=0,f=0;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-'),c=getchar();
    while(c>='0'&&c<='9') s=(s<<3)+(s<<1)+(c^'0'),c=getchar();
    return f?-s:s;
}

const int N=405,mod=1e9+7;
int n;
ll a[N][N<<1];
il ll qpow(ll x,ll k){
	ll ans=1;
	while(k){
		if(k&1) ans=ans*x%mod;
		x=x*x%mod;
		k>>=1;
	}
	return ans%mod;
}

il void Gauss_j(){	
	for(re int i=1,r;i<=n;++i){
		r=i;
		for(re int j=i+1;j<=n;++j)
			if(a[j][i]>a[r][i]) r=j;
		if(r!=i) swap(a[i],a[r]);
		if(!a[i][i]){puts("No Solution");return;}
		
		int kk=qpow(a[i][i],mod-2);	//求逆元 
		for(re int k=1;k<=n;++k){
			if(k==i) continue;
			int p=a[k][i]*kk%mod;
			for(re int j=i;j<=(n<<1);++j) 
				a[k][j]=((a[k][j]-p*a[i][j])%mod+mod)%mod;
		} 
		
		for(re int j=1;j<=(n<<1);++j) a[i][j]=(a[i][j]*kk%mod);
		//更新当前行 如果放在最后要再求一次逆元,不如直接放在这里  
	}	
	
	for(re int i=1;i<=n;++i){
		for(re int j=n+1;j<(n<<1);++j) printf("%lld ",a[i][j]);
		printf("%lld\n",a[i][n<<1]);
	}
}
int main(){
	n=read();
	for(re int i=1;i<=n;++i)
		for(re int j=1;j<=n;++j)
			a[i][j]=read(),a[i][i+n]=1;
	
	Gauss_j();
    return 0;
}
```

### 拉格朗日插值

```cpp
//已知函数n+1个点的值，求多项式的系数，时间复杂度O(n^2) 
#include<iostream>
#define mod 998244353
using namespace std;
int n;
long long x[2010],y[2010],k;//x[i],y[i]表示横、纵坐标 
long long quickpow(long long a,long long b)//快速幂 
{
	long long ans = 1,base = a;
	while(b)
	{
		if(b % 2 == 1)
		ans = base * ans % mod;
		base = base * base % mod;
		b = b / 2;
	}
	return ans;
}
int main()
{
	cin >> n >> k;
	for(int i = 1;i <= n;i++)
	cin >> x[i] >> y[i];
	long long ans = 0;
	for(int i = 1;i <= n;i++)
	{
		long long up = y[i],down = 1;
		for(int j = 1;j <= n;j++)
		{
			if(i != j)
			{
				up = (up * (k - x[j]) % mod + mod) % mod;//求分母 
				down = (down * (x[i] - x[j]) % mod + mod) % mod;//求分子 
			}
		}
		up = up * quickpow(down,mod - 2) % mod;
		ans = (ans + up) % mod;
	}
	cout << ans;
	return 0;
}
```

### FFT

```cpp
//FFT处理的问题是两个多项式的卷积，时间复杂度O(nlogn) 
#include<iostream>
#include<cmath>
using namespace std;
const double pi = acos(-1.0);
struct Complex
{
	double x,y;
	Complex operator+ (const Complex& t)const
	{
		return {x + t.x,y + t.y};
	}
	Complex operator- (const Complex& t)const
	{
		return {x - t.x,y - t.y};
	}
	Complex operator* (const Complex& t)const
	{
		return {x * t.x - y * t.y,x * t.y + y * t.x};
	}
}a[5000010],b[5000010];
int n,m,bit,tot,pos[5000010];
void init()
{
	while((1 << bit) < n + m + 1)
	bit++;
	tot = 1 << bit;//将项数补全成2的次幂
	for(int i = 0;i < tot;i++)
	pos[i] =  (pos[i >> 1] >> 1) | ((i & 1) << (bit - 1));//递推处理出序列最后的位置 
}
void fft(Complex a[],int mode)
{
	for(int i = 0;i < tot;i++)
	{
		if(i > pos[i])//注意只需交换一半，否则会回到原序列 
		swap(a[i],a[pos[i]]);
	}
	for(int mid = 1;mid < tot;mid = mid * 2)//从最下面一层递归向上处理 
	{
		auto wi = Complex({cos(pi / mid),mode * sin(pi / mid)});
		for(int i = 0;i < tot;i = i + 2 * mid)
		{
			auto w0 = Complex({1,0});
			for(int j = 0;j < mid;j++)
			{
				auto tx = a[i + j],ty = w0 * a[i + j + mid];
				a[i + j] = tx + ty,a[i + j + mid] = tx - ty;//左半部分加，右半部分减
				w0 = w0 * wi;
			}
		}
	}
	if(mode == -1)
	{
		for(int i = 0;i < tot;i++)
		a[i].x = a[i].x / tot;//最终的系数要除以tot 
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 0;i <= n;i++)
	scanf("%lf",&a[i].x);
	for(int i = 0;i <= m;i++)
	scanf("%lf",&b[i].x);
	init();
	fft(a,1),fft(b,1);//先转为点值表示法
	for(int i = 0;i < tot;i++)
	a[i] = a[i] * b[i];
	fft(a,-1);//转回系数表示法 
	for(int i = 0;i <= n + m;i++)
	printf("%d ",(int)(a[i].x + 0.5));
	return 0;
}
```

### MMT

```cpp
mul(a,b,c1,mod1),mul(a,b,c2,mod2),mul(a,b,c3,mod3);
//	for(int i = 0;i < lim;i++)
//	printf("%lld %lld %lld\n",c1[i],c2[i],c3[i]);
	for(int i = 0;i <= n + m;i++)
	{
		long long ans;
		long long k1,k4,x4,x;
		k1 = ((c2[i] - c1[i] + mod2) % mod2) * quickpow(mod1,mod2 - 2,mod2) % mod2;
		x4 = c1[i] + k1 * mod1;
		k4 = (((c3[i] - x4) % mod3 + mod3) % mod3) * quickpow(mod1 * mod2 % mod3,mod3 - 2,mod3) % mod3;
		x = (x4 + k4 * mod1 % p * mod2 % p) % p;
		ans = (x + p) % p;
		printf("%lld ",ans);
	}

```

### 多项式模板

```cpp
namespace poly
{
	int pos[N << 1],lg,lim,rt[N << 1];
	void initpoly(const int &n)
	{
		for(lg = 0,lim = 1;lim <= n;lim <<= 1)
		lg++;
		for(int i = 0;i < lim;i++)
		pos[i] = (pos[i >> 1] >> 1) | ((i & 1) << (lg - 1));
		for(int i = 1;i < lim;i <<= 1)
		{
			const int w = qpow(3,(mod - 1) / (i << 1));
			rt[i] = 1;
			for(int j = 1;j < i;j++)
			rt[i + j] = 1ll * rt[i + j - 1] * w % mod;
		}
	}
	void NTT(int *a,int type)
	{
		if(type == -1)
		reverse(a + 1,a + lim);
		for(int i = 0;i < lim;i++)
		{
			if(i < pos[i])
			swap(a[i],a[pos[i]]);
		}
		for(int i = 1;i < lim;i <<= 1)
		{
			for(int j = 0;j < lim;j += i << 1)
			{
				for(int k = 0;k < i;k++)
				{
					const int tx = a[j + k],ty = 1ll * rt[i + k] * a[i + j + k] % mod;
					fmod(a[j + k] = tx + ty),fmod(a[i + j + k] = tx - ty + mod);
				}
			}
		}
		if(type == -1)
		{
			int inv_lim = qpow(lim,mod - 2);
			for(int i = 0;i < lim;i++)
			a[i] = 1ll * a[i] * inv_lim % mod;
		}
	}
	void poly_mul(int *f,int *g,int *ans,int n,int m)
	{
		static int A[N << 1],B[N << 1];
		initpoly(n + m);
		for(int i = 0;i < lim;i++)
		A[i] = 0,B[i] = 0;
		for(int i = 0;i < n;i++)
		A[i] = f[i];
		for(int i = 0;i < m;i++)
		B[i] = g[i];
		NTT(A,1),NTT(B,1);
		for(int i = 0;i < lim;i++)
		A[i] = 1ll * A[i] * B[i] % mod;
		NTT(A,-1);
		for(int i = 0;i < n + m - 1;i++)
		ans[i] = A[i];
	}
	void poly_int(int *f,int *g,int n)
	{
		g[0] = 0;
		for(int i = 1;i <= n;i++)
		g[i] = 1ll * f[i - 1] * math::inv[i] % mod;
	}
	void poly_der(int *f,int *g,int n)
	{
		for(int i = 0;i < n - 1;i++)
		g[i] = 1ll * (i + 1) * f[i + 1] % mod;
		g[n - 1] = 0;
	}
	void poly_inv(int *f,int *g,int n)
	{
		static int A[N << 1],B[N << 1];
		if(n == 1)
		{
			g[0] = qpow(f[0],mod - 2);
			return ;
		}
		int m = (n + 1) >> 1;
		poly_inv(f,g,m);
		initpoly(n << 1);
		for(int i = 0;i < lim;i++)
		A[i] = 0,B[i] = 0;
		for(int i = 0;i < n;i++)
		A[i] = f[i];
		for(int i = 0;i < m;i++)
		B[i] = g[i];
		NTT(A,1),NTT(B,1);
		for(int i = 0;i < lim;i++)
		A[i] = 1ll * B[i] * (2 - 1ll * A[i] * B[i] % mod + mod) % mod;
		NTT(A,-1);
		for(int i = 0;i < n;i++)
		g[i] = A[i];
	}
}

```

### FWT

```cpp
//解决对下标位运算卷积问题的方法，时间复杂度O(nlogn) 
#include<iostream>
#define mod 998244353
#define inv 499122177
using namespace std;
long long a[200010],b[200010],A[200010],B[200010];
int n,tot;
void init()
{
	for(int i = 0;i < tot;i++)
	A[i] = a[i],B[i] = b[i];
}
void mul()
{
	for(int i = 0;i < tot;i++)
	A[i] = A[i] * B[i] % mod;
}
void print()
{
	for(int i = 0;i < tot;i++)
	cout << A[i] << ' ';
	cout << endl;
}
void fwt1(long long a[])//或运算正变换
{
	for(int i = 1;i <= n;i++)
	{
		int now = 1 << i;
		for(int j = 0;j < tot;j += now)
		{
			for(int k = 0;k < (now >> 1);k++)
			a[j + k + (now >> 1)] = (a[j + k] + a[j + k + (now >> 1)]) % mod;
		}
	}
}
void ifwt1(long long a[])//或运算逆变换 
{
	for(int i = n;i >= 1;i--)
	{
		int now = 1 << i;
		for(int j = 0;j < tot;j += now)
		{
			for(int k = 0;k < (now >> 1);k++)
			a[j + k + (now >> 1)] = (mod - a[j + k] + a[j + k + (now >> 1)]) % mod;
		}
	}
}
void fwt2(long long a[])//且运算正变换 
{
	for(int i = 1;i <= n;i++)
	{
		int now = 1 << i;
		for(int j = 0;j < tot;j += now)
		{
			for(int k = 0;k < (now >> 1);k++)
			a[j + k] = (a[j + k] + a[j + k + (now >> 1)]) % mod;
		}
	}
}
void ifwt2(long long a[])//且运算逆变换 
{
	for(int i = n;i >= 1;i--)
	{
		int now = 1 << i;
		for(int j = 0;j < tot;j += now)
		{
			for(int k = 0;k < (now >> 1);k++)
			a[j + k] = (mod + a[j + k] - a[j + k + (now >> 1)]) % mod;
		}
	}
}
void fwt3(long long a[])//异或运算正变换 
{
	for(int i = 1;i <= n;i++)
	{
		int now = 1 << i;
		for(int j = 0;j < tot;j += now)
		{
			for(int k = 0;k < (now >> 1);k++)
			{
				long long t1 = (a[k + j + (now >> 1)] + a[k + j]) % mod;
				long long t2 = (mod + a[k + j] - a[k + j + (now >> 1)]) % mod;
				a[k + j] = t1,a[k + j + (now >> 1)] = t2;
			}
		}
	}
}
void ifwt3(long long a[])//异或运算逆变换 
{
	for(int i = n;i >= 1;i--)
	{
		int now = 1 << i;
		for(int j = 0;j < tot;j += now)
		{
			for(int k = 0;k < (now >> 1);k++)
			{
				long long t1 = inv * ((a[j + k] + a[j + k + (now >> 1)]) % mod) % mod;
				long long t2 = inv * ((a[j + k] - a[j + k + (now >> 1)]) % mod + mod) % mod;
				a[j + k] = t1,a[j + k + (now >> 1)] = t2;
			}
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	tot = 1 << n;
	for(int i = 0;i < tot;i++)
	cin >> a[i];
	for(int i = 0;i < tot;i++)
	cin >> b[i];
	init(),fwt1(A),fwt1(B),mul(),ifwt1(A),print();
	init(),fwt2(A),fwt2(B),mul(),ifwt2(A),print();
	init(),fwt3(A),fwt3(B),mul(),ifwt3(A),print();
	return 0;
}
```

### 辛普森积分

```cpp
double simpson(double l,double r)
{
	double mid = l + (r - l) / 2;
	return (r - l) * (f(l) + 4 * f(mid) + f(r)) / 6;
}
double solve(double l,double r,double eps,double ans,int step)
{
	double mid = l + (r - l) / 2;
	double fl = simpson(l,mid),fr = simpson(mid,r);
	if(fabs(fl + fr - ans) < 15 * eps && step < 0)
	return fl + fr + (fl + fr - ans) / 15;
	return solve(l,mid,eps / 2,fl,step - 1) + solve(mid,r,eps / 2,fr,step - 1);
}

```

## 字符串

### 字符串哈希

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod1=1e9+7,mod2=1e9+9,base1=29,base2=31,maxn=2e5+10;
int n;
ll h1[maxn],h2[maxn],po1[maxn]={1},po2[maxn]={1};
char s[maxn];
struct Node{
	ll h1,h2;
};
inline Node get(int l,int r) {
	return {((h1[r]-h1[l-1]*po1[r-l+1])%mod1+mod1)%mod1,((h2[r]-h2[l-1]*po2[r-l+1])%mod2+mod2)%mod2};
}
int main() {
	scanf("%d%s",&n,s+1);
	for(int i=1;i<=n;i++) po1[i]=po1[i-1]*base1%mod1,po2[i]=po2[i-1]*base2%mod2;
	for(int i=1;i<=n;i++) h1[i]=(h1[i-1]*base1+s[i])%mod1,h2[i]=(h2[i-1]*base2+s[i])%mod2;
	return 0;
}
```

### KMP

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+10;
char a[maxn],b[maxn];
int la,lb,j,kmp[maxn];
int main() {
    cin>>(a+1);cin>>(b+1);
    la=strlen(a+1);lb=strlen(b+1);
    for(int i=2;i<=lb;i++) {
        while(j&&b[j+1]!=b[i]) j=kmp[j];
        if(b[j+1]==b[i]) j++;
        kmp[i]=j;
    }
	j=0;
    for(int i=1;i<=la;i++) {
        while(j&&b[j+1]!=a[i]) j=kmp[j];
        if(b[j+1]==a[i]) j++;
        if(j==lb) {
            cout<<i-lb+1<<endl;
            j=kmp[j];
        }
    }
    for(int i=1;i<=lb;i++) printf("%d ",kmp[i]);
    return 0;
}

```

### Z函数

$z[i]$ ：原串和 $s[i\sim n-1]$的最长公共前缀

* 字符串匹配

在 $t$ 里面找 $p$ ，则构造 $s=p+\$+t$，这样对于对于 $i\ge|p|+1$ ， $z[i]=|p|$即意味着是 $p$ 在 $t$ 的第 $i-|p|-1$ 的位置出现。

* 本质不同子串数

我们考虑增量，在 $s$ 后加一个字符 $c$ ，令 $t$ 为 $s+c$ 的倒序，则求 $t$ 的 $z_{\max}$ 即为 $t$ 的前缀重复最多的长度，也就是 $s+c$ 新增的后缀中重复的个数，对答案的贡献就是 $|t|-z_{\max}$，时间复杂度 $\Theta(N^2)$。

* 计算周期

对字符串 $s$ 和 $0 < p \le |s|$，若 $s[i] = s[i+p]$ 对所有 $i \in [0, |s| - p - 1]$ 成立，则称 $p$ 是 $s$ 的周期。

采用KMP的方法计算周期：对字符串 $s$ 和 $0 \le r < |s|$，若 $s$ 长度为 $r$ 的前缀和长度为 $r$ 的后缀相等，就称 $s$ 长度为 $r$ 的前缀是 $s$ 的 border。由 $s$ 有长度为 $r$ 的 border 可以推导出 $|s|-r$ 是 $s$ 的周期。

采用Z函数的方法计算周期：满足 $i+z[i]=n$ 的 $i$ 是 $s$ 的周期。

```cpp
//z[i]:s[0~n-1]和s[i~n-1]的LCP(最长公共前缀) 
//分类讨论继承之前信息,while执行次数总计线性,故可以O(N)实现 
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+10;
int n,z[maxn];
char s[maxn];
int main() {
	scanf("%s",s);n=strlen(s);
	int l=0,r=0;
	for(int i=1;i<n;i++) {
		if(i<=r&&z[i-l]<r-i+1) z[i]=z[i-l];
		else {
			z[i]=max(0,r-i+1);
			while(i+z[i]<n&&s[z[i]]==s[i+z[i]]) z[i]++;
		}
		if(i+z[i]-1>r) l=i,r=i+z[i]-1;
	}
	return 0;
}

```

### AC自动机加强版

给定n个字符串$t_i$和$s$，求每个$t_i$在$s$中出现次数

```cpp
#include<bits/stdc++.h>
using namespace std;
int n=1,cnt,maxn;
string ss,s[160];
int ans[160],exist[1000100],fail[1000100],next[1000100][26];
inline bool cmp(int x,int y){return x>y;}
inline void insert(int x)
{
    int u=0,len=s[x].size();
    for(int i=0;i<len;i++)
    {
        int c=s[x][i]-'a';
        if(!next[u][c]) next[u][c]=++cnt;
        u=next[u][c];
    }
    exist[u]=x;
}
inline void getfail()
{
    queue<int> q;
    for(int i=0;i<26;i++)//第二层的fail指针提前处理一下 
        if(next[0][i]) //如果存在子节点,则fail指向根节点,入队 
			q.push(next[0][i]),fail[next[0][i]]=0;
    while(!q.empty())
    {
		int u=q.front();q.pop();
		for(int i=0;i<26;i++)
			if(next[u][i])//存在这个子节点 
			//子节点的fail指针指向父节点的fail指针 
			//所指向的节点的相同子节点,入队 
				fail[next[u][i]]=next[fail[u]][i],q.push(next[u][i]);
			//不存在这个子节点 
			//当前节点的这个子节点指向当 
			//前节点fail指针的这个子节点 
			else next[u][i]=next[fail[u]][i];
    }
}
inline void work()
{
	cin>>ss;
    int u=0,len=ss.size();
    for(int i=0;i<len;i++)
    {
        u=next[u][ss[i]-'a'];
		for(int i=u;i;i=fail[i]) ans[exist[i]]++;
    }
}
int main()
{
	while(1)
	{
		cnt=0;maxn=0;
		memset(ans,0,sizeof ans);
		memset(next,0,sizeof next);
		memset(exist,0,sizeof exist);
		cin>>n;if(!n) return 0;
		for(int i=1;i<=n;i++) cin>>s[i],insert(i);
		getfail();work();
		for(int i=1;i<=n;i++) maxn=max(ans[i],maxn);cout<<maxn<<endl;
		for(int i=1;i<=n;i++) if(ans[i]==maxn) cout<<s[i]<<endl;
	}
	return 0;
}

```

### AC自动机加强版2

```cpp
//本题为AC自动机的优化：构建fail树 
//每次暴力跳fail,深度至少-1,所以极端情况下O(n)的复杂度就假了(比如aaaaaaaaa) 
//这里连fail[i]->i的有向边，文本串匹配时，直接让这个节点的size++ 
//最后从0(即虚拟根节点)dfs一遍,将所有子节点的size加到父节点上即可 
//另外插入时需记录每个串的结尾所对应的点的编号exist[] 
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+10;
int n,tot,cnt,head[maxn],ans[160],exist[maxn],fail[maxn],siz[maxn],nex[maxn][26];
char s[maxn*10];
struct Edge{int to,nex;} e[maxn];
inline void add(int u,int to) {e[++cnt]=(Edge){to,head[u]};head[u]=cnt;}
inline void dfs(int u) {for(int i=head[u];i;i=e[i].nex) dfs(e[i].to),siz[u]+=siz[e[i].to];}
inline void insert(int pos) {
	scanf("%s",s);
	int u=0,len=strlen(s);
	for(int i=0;i<len;i++) {
		int c=s[i]-'a';
		if(!nex[u][c]) nex[u][c]=++tot;
		u=nex[u][c];
	}
	exist[pos]=u;
}
queue<int> q;
inline void get_fail() {
	for(int i=0;i<26;i++) if(nex[0][i]) fail[nex[0][i]]=0,q.push(nex[0][i]);
	while(q.size()) {
		int u=q.front();q.pop();
		for(int i=0;i<26;i++) {
			if(nex[u][i]) fail[nex[u][i]]=nex[fail[u]][i],q.push(nex[u][i]);
			else nex[u][i]=nex[fail[u]][i];
		}
	}
}
inline void AC() {
	scanf("%s",s);
	int u=0,len=strlen(s);
	for(int i=0;i<len;i++) {
		u=nex[u][s[i]-'a'];
		siz[u]++;
	}
	for(int i=1;i<=tot;i++) add(fail[i],i);
	dfs(0);
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) insert(i);
	get_fail();AC();
	for(int i=1;i<=n;i++) printf("%d\n",siz[exist[i]]);
	return 0;
}

```

### 后缀数组

$O(n\log n)$

$sa[i]$ 表示将所有后缀排序后第 $i$ 小的后缀的编号，$rk[i]$ 表示后缀 $i$ 的排名

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+10;
char s[N];
int n,sa[N],rk[N],oldrk[N<<1],id[N],key1[N],cnt[N],h[N];
inline bool cmp(int x,int y,int w) {
	return oldrk[x]==oldrk[y]&&oldrk[x+w]==oldrk[y+w];
}
inline void work(char s[]) {
	int i,m=127,p,w;
	n=strlen(s+1);
	for(i=1;i<=n;++i) ++cnt[rk[i]=s[i]];
	for(i=1;i<=m;++i) cnt[i]+=cnt[i-1];
	for(i=n;i>=1;--i) sa[cnt[rk[i]]--]=i;
	for(w=1;;w<<=1,m=p) { 
		for(p=0,i=n;i>n-w;--i) id[++p]=i;
		for(i=1;i<=n;++i)
			if(sa[i]>w) id[++p]=sa[i]-w;
		memset(cnt,0,sizeof(cnt));
		for(i=1;i<=n;++i) ++cnt[key1[i]=rk[id[i]]];
		for(i=1;i<=m;++i) cnt[i]+=cnt[i-1];
		for(i=n;i>=1;--i) sa[cnt[key1[i]]--]=id[i];
		memcpy(oldrk+1,rk+1,n*sizeof(int));
		for(p=0,i=1;i<=n;++i)
			rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p;
		if(p==n) break;
	}
	for(int i=1,k=0;i<=n;++i) {
		if(rk[i]==0) continue;
		if(k) --k;
		while(s[i+k]==s[sa[rk[i]-1]+k]) ++k;
		h[rk[i]]=k;
	}
	for(int i=1;i<=n;i++) cout<<h[i]<<" "; 
}
int main() {
	scanf("%s",s+1);
	work(s);
	return 0;
}
```

$O(n)$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+100;
char str[N];
int n,m,sa[N],s[N<<1],tp[N<<1],lms[N],cnt[N],cur[N],rk[N],h[N];
void inducedsort(int n,int m,int n1,int *s,int *tp,int *v) {
    fill_n(sa,n,-1);
    fill_n(cnt,m,0);
    for(int i=0;i<n;i++) cnt[s[i]]++;
    for(int i=1;i<m;i++) cnt[i]+=cnt[i-1];
    for(int i=0;i<m;i++) cur[i]=cnt[i]-1;
    for(int i=n1-1;i>=0;i--) sa[cur[s[v[i]]]--]=v[i];
    for(int i=1;i<m;i++) cur[i]=cnt[i-1];
    for(int i=0;i<n;i++) if(sa[i]>0&&tp[sa[i]-1]) sa[cur[s[sa[i]-1]]++]=sa[i]-1;
    for(int i=0;i<m;i++) cur[i]=cnt[i]-1;
    for(int i=n-1;i>=0;i--) if(sa[i]>0&&!tp[sa[i]-1]) sa[cur[s[sa[i]-1]]--]=sa[i]-1;
}
void sais(int n,int m,int *s,int *tp,int *lms) {
    int n1=tp[n-1]=0,ch=rk[0]=-1,*s1=s+n;
    for(int i=n-2;i>=0;i--) tp[i]=s[i]==s[i+1]?tp[i+1]:s[i]>s[i+1];
	for(int i=1;i<n;i++) rk[i]=tp[i-1]&&!tp[i]?(lms[n1]=i,n1++):-1;
	inducedsort(n,m,n1,s,tp,lms);
	for(int i=0;i<n;i++) {
        int x=rk[sa[i]],y;
		if(x!=-1) {
            if(ch<1||(lms[x+1]-lms[x]!=lms[y+1]-lms[y])) ch++;
			else {
                for(int j=lms[x],k=lms[y];j<=lms[x+1];j++,k++) {
                    if((s[j]<<1|tp[j])!=(s[k]<<1|tp[k])) {
						ch++;
                        break;
                    }
                }
            }
            s1[y=x]=ch;
		}
    }
    if(ch+1<n1) sais(n1,ch+1,s1,tp+n,lms+n1);
    else
        for(int i=0;i<n1;i++)
            sa[s1[i]]=i;
    for(int i=0;i<n1;i++) s1[i]=lms[sa[i]];
    inducedsort(n,m,n1,s,tp,s1);
}
void get_height() {
    for(int i=0;i<n;i++) rk[sa[i]]=i;
    for(int i=0,k=h[0]=0;i<n-1;i++) {
        int j=sa[rk[i]-1];
        while(i+k<n&&j+k<n&&s[i+k]==s[j+k]) k++;
        if((h[rk[i]]=k)) k--;
    }
}
int main() {
	scanf("%s",str); 
    n=strlen(str);
    for(int i=0;i<n;i++) s[i]=str[i];
    s[n++]=0;
    m=128;
    sais(n,m,s,tp,lms);
    get_height();
    for(int i=1;i<n;i++) printf("%d ",sa[i]+1);
//	for(int i=2;i<n;i++) printf("%d%c",h[i],i==n-1?'\n':' ');
    return 0;
}

```

### 在字符串中找子串

在线地在主串 $T$ 中寻找模式串 $S$。在线的意思是，我们已经预先知道知道主串 $T$，但是当且仅当询问时才知道模式串 $S$。我们可以先构造出 $T$ 的后缀数组，然后查找子串 $S$。若子串 $S$ 在 $T$ 中出现，它必定是 $T$ 的一些后缀的前缀。因为我们已经将所有后缀排序了，我们可以通过在 $p$ 数组中二分 $S$ 来实现。比较子串 $S$ 和当前后缀的时间复杂度为 $O(|S|)$，因此找子串的时间复杂度为 $O(|S|\log |T|)$。注意，如果该子串在 $T$ 中出现了多次，每次出现都是在 $p$ 数组中相邻的。因此出现次数可以通过再次二分找到，输出每次出现的位置也很轻松。

如果用传统 KMP 算法，单次复杂度为 $O(|S|+|T|)$ ，文本串较长，查询较多时复杂度较劣

* LCP（最长公共前缀）

  两个字符串 $S$ 和 $T$ 的 LCP 就是最大的 $x$($x\le \min(|S|, |T|)$) 使得 $S_i=T_i\ (\forall\ 1\le i\le x)$。

  下文中以 $lcp(i,j)$ 表示后缀 $i$ 和后缀 $j$ 的最长公共前缀（的长度）。

* height 数组的定义

  $height[i]=lcp(sa[i],sa[i-1])$，即第 $i$ 名的后缀与它前一名的后缀的最长公共前缀。

  $height[1]$ 可以视作 $0$。

* 两子串最长公共前缀

  $lcp(sa[i],sa[j])=\min\{height[i+1..j]\}$

  感性理解：如果 $height$ 一直大于某个数，前这么多位就一直没变过；反之，由于后缀已经排好序了，不可能变了之后变回来。

* 比较一个字符串的两个子串的大小关系

  假设需要比较的是 $A=S[a..b]$ 和 $B=S[c..d]$ 的大小关系。

  若 $lcp(a, c)\ge\min(|A|, |B|)$，$A<B\iff |A|<|B|$。

  否则，$A<B\iff rk[a]< rk[c]$。

* 不同子串的数目

  子串就是后缀的前缀，所以可以枚举每个后缀，计算前缀总数，再减掉重复。

  「前缀总数」其实就是子串个数，为 $n(n+1)/2$。

  如果按后缀排序的顺序枚举后缀，每次新增的子串就是除了与上一个后缀的 LCP 剩下的前缀。这些前缀一定是新增的，否则会破坏 $lcp(sa[i],sa[j])=\min\{height[i+1..j]\}$ 的性质。只有这些前缀是新增的，因为 LCP 部分在枚举上一个前缀时计算过了。

  所以答案为：

  $\frac{n(n+1)}{2}-\sum\limits_{i=2}^nheight[i]$

### 出现至少 k 次的子串的最大长度

出现至少 $k$ 次意味着后缀排序后有至少连续 $k$ 个后缀以这个子串作为公共前缀。

所以，求出每相邻 $k-1$ 个 $height$ 的最小值，再求这些最小值的最大值就是答案。

可以使用单调队列 $O(n)$ 解决，但使用其它方式也足以 AC。

### Manacher

求回文串，基础是求奇回文串，中间添加占位符可以使之为奇回文串

```cpp
//Manacher:
//r[i]表示以第i个字符能扩展的最大长度，即s[i-r[i]]!=s[i+r[i]],s[i-r[i]+1]==s[i+r[i]-1] 
//将原串所有相邻字符之前插入一个'|',这样就都是奇回文串 
//还有就是令s[0]='~'   *trick 防止下标溢出  
#include<bits/stdc++.h>
using namespace std;
const int maxn=2.2e7+10;
int n,pos,ans,r[maxn];
char s[maxn];
inline void init() {
	char c=getchar();
	s[0]='~';s[++n]='|';
	while(c<'a'||c>'z') c=getchar();
	while(c>='a'&&c<='z') s[++n]=c,s[++n]='|',c=getchar();
}
int main() {
	init();
	for(int i=1;i<=n;i++) {
		r[i]=pos+r[pos]>i?min(r[(pos<<1)-i],r[pos]+pos-i):1;
		while(s[i+r[i]]==s[i-r[i]]) r[i]++;
		pos=i+r[i]>pos+r[pos]?i:pos;
		ans=r[i]>ans?r[i]:ans;
	}
	printf("%d",ans-1);//记的减一，因为原串开头结尾都加了一个'|' 
	return 0;
}

```

## 数据结构

### 单调队列

```cpp
void getmin() {  // 得到这个队列里的最小值，直接找到最后的就行了
  int head = 0, tail = -1;
  for (int i = 1; i < k; i++) {
    while (head <= tail && a[q[tail]] >= a[i]) tail--;
    q[++tail] = i;
  }
  for (int i = k; i <= n; i++) {
    while (head <= tail && a[q[tail]] >= a[i]) tail--;
    q[++tail] = i;
    while (q[head] <= i - k) head++;
    printf("%d ", a[q[head]]);
  }
}

void getmax() {  // 和上面同理
  int head = 0, tail = -1;
  for (int i = 1; i < k; i++) {
    while (head <= tail && a[q[tail]] <= a[i]) tail--;
    q[++tail] = i;
  }
  for (int i = k; i <= n; i++) {
    while (head <= tail && a[q[tail]] <= a[i]) tail--;
    q[++tail] = i;
    while (q[head] <= i - k) head++;
    printf("%d ", a[q[head]]);
  }
}
```

### 树的哈希

$f_i$ 表示以 $i$ 为根节点的子树的哈希值，该代码是求一棵树的所有本质不同的子树个数，答案即为 `trees.size()` ，若用于判断两棵子树是否相同，可以用常见树形DP $O(N)$ 求出以每个点为根的哈希值，然后排序后比较是否完全相同。也可以跑一遍树形DP找到树的重心（一个或两个），然后以此为根计算哈希值并比较。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int maxn=2e5+10;
int T,n,cnt,head[maxn];
struct Edge{int to,nex;} e[maxn<<1];
inline void add(int u,int to) {
	e[++cnt].to=to;e[cnt].nex=head[u];head[u]=cnt;
}
inline int gint() {
	int ff=1,ee=0;char ss=getchar();
	while((ss<'0'||ss>'9')&&ss!='-') ss=getchar();
	while((ss>='0'&&ss<='9')||ss=='-') 
	{if(ss=='-') ff=-1;else ee=(ee<<1)+(ee<<3)+ss-'0';ss=getchar();}
	return ee*ff;
}
const ull mask=chrono::steady_clock::now().time_since_epoch().count();
inline ull shift(ull x) {
	x^=mask;x^=x<<13;
	x^=x>>7;x^=x<<17;
	x^=mask;
	return x;
}
ull f[maxn];
set<ull> trees;
inline void getHash(int u, int p) {
	vector<int> ve;
	f[u]=1;
	for(int i=head[u];i;i=e[i].nex) {
		int v=e[i].to;
		if(v==p) continue;
		getHash(v,u);
		f[u]+=shift(f[v]);
	}
	trees.insert(f[u]);
}
int main() {
	T=gint();
	while(T--) {
		n=gint();cnt=0;trees.clear();
		for(int i=1;i<=n;i++) head[i]=0,f[i]=0;
		for(int i=1,x,y;i<n;i++) {
			x=gint();y=gint();
			add(x,y);add(y,x);
		}
		getHash(1,-1);
	}
	return 0;
}
```

### 主席树

静态区间第 $k$ 小

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+10;
int n,m,nn,cnt,a[maxn*20];
inline int gint() {
	int ff=1,ee=0;char ss=getchar();
	while((ss<'0'||ss>'9')&&ss!='-')ss=getchar();
	while((ss>='0'&&ss<='9')||ss=='-')
	{if(ss=='-') ff=-1;else ee=ee*10+ss-'0';ss=getchar();}
	return ee*ff;
}
struct TREE{
	int rt[maxn],lc[maxn*40],rc[maxn*40],sum[maxn*40];
	struct Node{int l,r,siz;} tr[maxn*40];
	inline int add(int p,int x,int l,int r) {
		int pp=++cnt;
		tr[pp]=tr[p];tr[pp].siz++;//继承 
		if(l==r) return pp;
		int mid=(l+r)>>1;
		if(x<=mid) tr[pp].l=add(tr[pp].l,x,l,mid);
		else tr[pp].r=add(tr[pp].r,x,mid+1,r);
		return pp;
	}
	inline int query(int ll,int rr,int l,int r,int k) {
		if(l==r) return l;
		int sum=tr[tr[rr].l].siz-tr[tr[ll].l].siz,mid=(l+r)>>1;
		if(k<=sum) return query(tr[ll].l,tr[rr].l,l,mid,k);
		else return query(tr[ll].r,tr[rr].r,mid+1,r,k-sum);
	}
} s1,s2;
int main() {
    n=gint();m=gint();
    for(int i=1;i<=n;i++) a[i]=gint();
	for(int i=1;i<=n;i++) s1.rt[i]=s1.add(s1.rt[i-1],a[i],-1e9,1e9);
	while(m--) {
		int x=gint(),y=gint(),k=gint();
		printf("%d\n",s1.query(s1.rt[x-1],s1.rt[y],-1e9,1e9,k));
	}
	return 0;
}

```

### 可持久化01trie

操作 `A` ：在数列末尾增加一个 `x` 

操作 `Q` ：查询区间 `[l,r]` 中的 `p` 使得 $x\text{^}\bigoplus_{i=p}^n a[i]$ 最大

建议开32倍空间

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=6e5+10;
int T,n,m,idx,a[maxn],s[maxn],rt[maxn];
struct Tree{
	int siz,ch[2];
} tr[maxn*32];
void insert(int x,int k,int pre,int &now) {
	now=++idx;tr[now]=tr[pre];tr[now].siz++;
	if(k<0) return ;//注意在开头return否则会忽略2^0这一位 
	int t=x>>k&1;
	tr[now].ch[t^1]=tr[pre].ch[t^1];
	insert(x,k-1,tr[pre].ch[t],tr[now].ch[t]);
}
inline int query(int l,int r,int x) {
	int res=0;
	for(int i=25;~i;i--) {
		int t=x>>i&1;
		if(tr[tr[r].ch[t^1]].siz-tr[tr[l].ch[t^1]].siz>0) {
			l=tr[l].ch[t^1];
			r=tr[r].ch[t^1];
			res+=1<<i;
		}
		else {
			l=tr[l].ch[t];
			r=tr[r].ch[t];
		}
	}
	return res;
}
inline int gint() {
	char ch=getchar();int s=0,f=1;
	while(!isdigit(ch)) {if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) {s=(s<<3)+(s<<1)+(ch^48);ch=getchar();}
	return s*f;
}
char op[2];
int main() {
	n=gint();m=gint();
	insert(0,25,0,rt[0]);
	for(int i=1;i<=n;i++) {
		a[i]=gint();
		s[i]=s[i-1]^a[i];
		insert(s[i],25,rt[i-1],rt[i]);
	}
	while(m--) {
		scanf("%s",op);
		if(op[0]=='A') {
			n++;a[n]=gint();s[n]=s[n-1]^a[n];
			insert(s[n],25,rt[n-1],rt[n]);
		}
		else {
			int l=gint(),r=gint(),x=gint();//注意这里的一个-2一个-1
			printf("%d\n",query(l>=2?rt[l-2]:0,rt[r-1],x^s[n]));
		}
	}
	return 0;
}

```

### 李超线段树

1. 在平面上加入一条线段。记第 $i$ 条被插入的线段的标号为 $i$ 。
2. 给定一个数 $k$ ，询问与直线 $x=k$ 相交的线段中，交点纵坐标最大的线段的编号。

这个板子是强制在线的

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mid ((l+r)>>1)
#define lson k<<1,l,mid
#define rson k<<1|1,mid+1,r
inline int read() {
    int x=0,f=1;char p=getchar();
    while(!isdigit(p)){if(p=='-') f=-1;p=getchar();}
    while(isdigit(p)) x=(x<<3)+(x<<1)+p-48,p=getchar();
    return x*f;
}
const int maxn=1e6+5,mod1=39989,mod2=1e9;
int n,lastans,cnt;
struct node{int id;} tr[maxn<<2];
struct Node{double k,b;} line[maxn];
inline double calc(int id,int x) {return line[id].k*x+line[id].b;}
inline void insert(int k,int l,int r,int id) {
    if(l==r) {
        double xid=calc(id,l),yid=calc(tr[k].id,l);
        if(xid>yid) tr[k].id=id;
        return ;
    }
    double xmid=calc(id,mid),ymid=calc(tr[k].id,mid);
    double xl=calc(id,l),yl=calc(tr[k].id,l);
    double xr=calc(id,r),yr=calc(tr[k].id,r);
    if(xl>=yl&&xr>=yr) {
        if(xl!=yl&&xr!=yr) {tr[k].id=id;return;}
        if(xl==yl&&xr==yr) return;
        if(xl==yl) {
            insert(k<<1,l,mid,tr[k].id);
            tr[k].id=id;
            return ;
        }
        if(xr==yr) {
            insert(rson,tr[k].id);
            tr[k].id=id;
            return ;
        }
    }
    if(xl<yl&&xr<yr) return ;
    if(xmid>ymid) {
        int yid=tr[k].id;
        tr[k].id=id;
        if(xl>yl) {insert(rson,yid);return;}
        if(xr>yr) {insert(lson,yid);return;}
    }
    if(xmid<=ymid) {
        if(xl>yl) {insert(lson,id);return;}
        if(xr>yr) {insert(rson,id);return;}
    }
}
inline void update(int k,int l,int r,int L,int R,int id) {
    if(L<=l&&r<=R) {insert(k,l,r,id);return;}
    if(L<=mid) update(k<<1,l,mid,L,R,id);
    if(R>mid) update(k<<1|1,mid+1,r,L,R,id);
}
inline int query(int k,int l,int r,int pos) {
    if(l==r) return tr[k].id;
    double jisx,jisk=calc(tr[k].id,pos);
    if(pos<=mid) {
        int x=query(lson,pos);
    	jisx=calc(x,pos);
        if(jisk==jisx) return min(x,tr[k].id);
		return jisk>jisx?tr[k].id:x;
    }
	int x=query(rson,pos);
	jisx=calc(x,pos);
	if(jisk==jisx) return min(x,tr[k].id);
	return jisk>jisx?tr[k].id:x;   
}
int main() {
    n=read();
    while(n--) {
        int opt=read();
        if(opt==1) {
            int x0=read(),y0=read(),x1=read(),y1=read();
            x0=(x0+lastans-1)%mod1+1,y0=(y0+lastans-1)%mod2+1;
            x1=(x1+lastans-1)%mod1+1,y1=(y1+lastans-1)%mod2+1;
            if(x0>x1) swap(x0,x1),swap(y0,y1);
            if(x0==x1) line[++cnt].k=0,line[cnt].b=max(y1,y0);//插入了一条竖直线段  
            else line[++cnt].k=(1.0*(y0-y1))/(1.0*(x0-x1)),
                line[cnt].b=y0-x0*line[cnt].k;//计算斜率和截距  
			update(1,1,mod1,x0,x1,cnt);//加入新线段  
        }
        if(opt==0) {
            int x=read();x=(x+lastans-1)%mod1+1;
            printf("%d\n",lastans=query(1,1,mod1,x));
            continue;
        }
    }
    return 0;
}

```

### fhq-treap

支持以下操作

1. 插入 $x$ 数
2. 删除 $x$ 数(若有多个相同的数，应只删除一个)
3. 查询 $x$ 数的排名(排名定义为比当前数小的数的个数 $+1$ )
4. 查询排名为 $x$ 的数
5. 求 $x$ 的前驱(前驱定义为小于 $x$，且最大的数)
6. 求 $x$ 的后继(后继定义为大于 $x$，且最小的数)

```cpp
//fhq-treap:主要就是两个函数split(拆分)和mergy(合并) 
//将对平衡树的操作转变为这两个操作，在佐之以kth(查询排名) 
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int n,tot,root;
struct fhq{int l,r,rnd,dat,size;} tr[maxn];
inline int read() {
	char ch=getchar();int s=0,f=1;
	while(!isdigit(ch)) {if (ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) {s=(s<<3)+(s<<1)+ch-'0';ch=getchar();}
	return s*f;
}
inline void update(int x) {tr[x].size=tr[tr[x].l].size+tr[tr[x].r].size+1;}
inline int mergy(int x,int y) {
	if(!x||!y) return x|y;
	if(tr[x].rnd<tr[y].rnd) {
		tr[x].r=mergy(tr[x].r,y);update(x);
		return x;
	}
	else {
		tr[y].l=mergy(x,tr[y].l);update(y);
		return y;
	}
}
inline void split(int p,int k,int &x,int &y)
{	//将权值小于等于k的分为x的左子树，其余分为右子树 
	if(!p) {x=y=0;return;}
	if(k>=tr[p].dat) x=p,split(tr[p].r,k,tr[p].r,y);
	else y=p,split(tr[p].l,k,x,tr[p].l);    
	update(p);
}
inline int kth(int p,int k) {//在以p为根的子树中查询排名为k的树的对应节点 
	while(1) {
		if(k<=tr[tr[p].l].size) p=tr[p].l;
		else if(k==tr[tr[p].l].size+1) return p;
		else k-=(tr[tr[p].l-].size+1),p=tr[p].r;
	}
}
int main() {
	n=read();
	int w,x,y,z,opt;
	while (n--) {
		opt=read();w=read();
		if(opt==1) {
			//先将树劈成两半，左半边小于等于t，右半边大于t，分别合并即可 
			split(root,w,x,y);
			tr[++tot].dat=w;tr[tot].rnd=rand();tr[tot].size=1;
			root=mergy(mergy(x,tot),y);
		}
		if(opt==2) {
			split(root,w,x,z);
			split(x,w-1,x,y);
			y=mergy(tr[y].l,tr[y].r);//再依次与x,z合并即起到删除的效果 
			root=mergy(mergy(x,y),z);
		}
		if(opt==3) {
			//拆成两半，左半边x小于等于w-1 排名即为左子树大小+1 
			split(root,w-1,x,y);printf("%d\n",tr[x].size+1);
			root=mergy(x,y);
		}
		if(opt==4) printf("%d\n",tr[kth(root,w)].dat);
		if(opt==5) {
			//将树劈成两半，左边x小于等于t-1，那么比t小的最大的数就是x中最大的数 
			split(root,w-1,x,y);printf("%d\n",tr[kth(x,tr[x].size)].dat);
			root=mergy(x,y);
		}
		if(opt==6) {
			//将树劈成两半，右边y大于t，那么比t大的最小的数就是y中最小的数 
			split(root,w,x,y);printf("%d\n",tr[kth(y,1)].dat);
			root=mergy(x,y);
		}
	}
	return 0;
}
```

### LCA（倍增）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e5+10;
struct Edge{int to,nex;} e[2*maxn];
int n,m,s,cnt,dep[maxn],fa[maxn][22],log2[maxn],head[maxn];
void add(int u,int v) {e[++cnt].to=v;e[cnt].nex=head[u];head[u]=cnt;}
void dfs(int f,int ff) { 
    dep[f]=dep[ff]+1;
    fa[f][0]=ff;
    for(int i=1;(1<<i)<=dep[f];i++) fa[f][i]=fa[fa[f][i-1]][i-1];
    for(int i=head[f];i;i=e[i].nex) if(e[i].to!=ff) dfs(e[i].to,f);
}
inline int LCA(int x,int y) {
    if(dep[x]<dep[y]) swap(x,y);
    while(dep[x]>dep[y]) x=fa[x][log2[dep[x]-dep[y]]];
    if(x==y) return x;
    for(int k=log2[dep[x]];k>=0;k--) if(fa[x][k]!=fa[y][k]) x=fa[x][k],y=fa[y][k];
    return fa[x][0];
}
int main() {
    int x,y;
    scanf("%d%d%d",&n,&m,&s);
    for(int i=1;i<=n-1;i++) scanf("%d%d",&x,&y),add(x,y),add(y,x);
    dfs(s,0);
    for(int i=2;i<=n;i++) log2[i]=log2[i>>1]+1;
    for(int i=1;i<=m;i++) scanf("%d%d",&x,&y),printf("%d\n",LCA(x,y));
    return 0;
}
```

### LCA（树剖）

```cpp
//轻重链剖分求LCA，据说常数较小，且空间比倍增小 
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e5+10;
struct Edge{int to,nex;} e[maxn<<1];
int n,m,s,cnt,head[maxn],dep[maxn],siz[maxn],son[maxn],top[maxn],f[maxn];
inline void add(int u,int to) {e[++cnt].to=to;e[cnt].nex=head[u];head[u]=cnt;}
inline void pre(int x) {
    siz[x]=1;dep[x]=dep[f[x]]+1;
    for(int i=head[x];i;i=e[i].nex) {
        int v=e[i].to;
        if(v==f[x])continue;
        f[v]=x;pre(v);
        siz[x]+=siz[v];
        if(!son[x]||siz[son[x]]<siz[v]) son[x]=v;
    }
}
inline void dfs(int x,int topf) {
    top[x]=topf;
    if(son[x]) dfs(son[x],topf);
    for(int i=head[x];i;i=e[i].nex) {
        int v=e[i].to;
        if(v==f[x]||v==son[x])continue;
        dfs(v,v);
    }
}
inline void write(int x) {
	if(x) write(x/10);
	else return ;
	putchar(x%10|48);
}
inline int gint() {//快读 
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
int main()
{	
    n=gint();m=gint();s=gint();
    for(int i=1,x,y;i<n;i++) x=gint(),y=gint(),add(x,y),add(y,x);
    pre(s);dfs(s,s);
    while(m--) {
    	int x=gint(),y=gint();
        while(top[x]!=top[y]) dep[top[x]]>=dep[top[y]]?x=f[top[x]]:y=f[top[y]];
        write(dep[x]<dep[y]?x:y);putchar('\n');
    }
    return 0;
}
```

### LCA(dfn序)

$O(n\log n)$ 预处理，$O(1)$ 查询（通过ST表）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+10;
int n,q,cnt,head[maxn];
struct Edge{
	int to,nex;
} e[maxn<<1];
inline void add(int u,int to) {
	e[++cnt].to=to;e[cnt].nex=head[u];head[u]=cnt;
}
int f[maxn],LOG[maxn],dep[maxn],po[22]={1};
int idx,dfn[maxn],id[maxn];
inline void dfs(int u) {
	dfn[u]=++idx;id[idx]=u;
	for(int i=head[u];i;i=e[i].nex) {
		int v=e[i].to;if(dfn[v]) continue;
		f[v]=u;dep[v]=dep[u]+1;
		dfs(v);
	}
}
int pos[maxn][22],g[maxn][22];
inline int LCA(int x,int y) {
	if(x==y) return x;
	if(dfn[x]>dfn[y]) swap(x,y);
	x=dfn[x]+1;y=dfn[y];
	int p=LOG[y-x+1];
	if(g[x][p]<g[y-po[p]+1][p]) return f[pos[x][p]];
	else return f[pos[y-po[p]+1][p]];
}
int rt;
int main() {
	scanf("%d%d%d",&n,&q,&rt);LOG[0]=-1;
	for(int i=2;i<=n;i++) LOG[i]=LOG[i>>1]+1;
	for(int i=1;i<=20;i++) po[i]=po[i-1]<<1;
	for(int i=1,x,y;i<n;i++) {
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs(rt);
	for(int i=1;i<=n;i++) {
		g[i][0]=dep[id[i]];
		pos[i][0]=id[i];
	}
	for(int j=1;j<=20;j++) {
		for(int i=1;i+po[j]-1<=n;i++) {
			if(g[i][j-1]<g[i+po[j-1]][j-1]) {
				g[i][j]=g[i][j-1];
				pos[i][j]=pos[i][j-1];
			}
			else {
				g[i][j]=g[i+po[j-1]][j-1];
				pos[i][j]=pos[i+po[j-1]][j-1];
			}
		}
	}
	while(q--) {
		int x,y;scanf("%d%d",&x,&y);
		printf("%d\n",LCA(x,y));
	}
	return 0;
}

```



### 虚树

```cpp
/* LCA */

int dfn[maxn];
bool valid[maxn];
int h[maxn], m, a[maxn], len;  // 存储关键点

bool cmp(int x, int y) {
  return dfn[x] < dfn[y];  // 按照 dfn 序排序
}

void build_virtual_tree() {
  sort(h + 1, h + m + 1, cmp);  // 把关键点按照 dfn 序排序
  for (int i = 1; i < m; ++i) {
    a[++len] = h[i];
    a[++len] = lca(h[i], h[i + 1]);  // 插入 lca
  }
  a[++len] = h[m];
  sort(a + 1, a + len + 1, cmp);  // 把所有虚树上的点按照 dfn 序排序
  len = unique(a + 1, a + len + 1) - a - 1;  // 去重
  for (int i = 1, lc; i < len; ++i) {
    lc = lca(a[i], a[i + 1]);
    conn(lc, a[i + 1]);  // 连边，如有边权 就是 distance(lc,a[i+1])
  }
}

/* Monotonous Stack */

bool cmp(const int x, const int y) { return id[x] < id[y]; }

void build() {
  sort(h + 1, h + k + 1, cmp);
  sta[top = 1] = 1, g.sz = 0, g.head[1] = -1;
  // 1 号节点入栈，清空 1 号节点对应的邻接表，设置邻接表边数为 1
  for (int i = 1, l; i <= k; ++i)
    if (h[i] != 1) {
      // 如果 1 号节点是关键节点就不要重复添加
      l = lca(h[i], sta[top]);
      // 计算当前节点与栈顶节点的 LCA
      if (l != sta[top]) {
        // 如果 LCA 和栈顶元素不同，则说明当前节点不再当前栈所存的链上
        while (id[l] < id[sta[top - 1]])
          // 当次大节点的 Dfs 序大于 LCA 的 Dfs 序
          g.push(sta[top - 1], sta[top]), top--;
        // 把与当前节点所在的链不重合的链连接掉并且弹出
        if (id[l] > id[sta[top - 1]])
          // 如果 LCA 不等于次大节点（这里的大于其实和不等于没有区别）
          g.head[l] = -1, g.push(l, sta[top]), sta[top] = l;
        // 说明 LCA 是第一次入栈，清空其邻接表，连边后弹出栈顶元素，并将 LCA
        // 入栈
        else
          g.push(l, sta[top--]);
        // 说明 LCA 就是次大节点，直接弹出栈顶元素
      }
      g.head[h[i]] = -1, sta[++top] = h[i];
      // 当前节点必然是第一次入栈，清空邻接表并入栈
    }
  for (int i = 1; i < top; ++i)
    g.push(sta[i], sta[i + 1]);  // 剩余的最后一条链连接一下
  return;
}
```

### 树链剖分

支持 修改/查询  路径/子树 点权

```cpp
#include<bits/stdc++.h>
#define L(x) x<<1
#define R(x) x<<1|1
using namespace std;
inline int gint()//拙劣的非负快读（据说还有更快的）。 
{
    int ff=1,ee=0;char ss=getchar();
    while(ss<'0'||ss>'9') ss=getchar();
    while(ss>='0'&&ss<='9') {ee=(ee<<1)+(ee<<3)+(ss^48);ss=getchar();}
    return ee*ff;
}
int n,m,root,mod,idx;
int cnt,head[200200],w[200200],wt[200200];//w,wt初始,新点权 
int a[800800],lazy[800800];//a:线段树节点值 lazy操作 
int son[200200],id[200200],fa[200200],dep[200200],size[200200],top[200200]; 
//son:重儿子编号,id:新编号,fa:父亲节点,dep:深度,size:子树大小,top:当前链顶端节点 
struct Edge{int to,next;} edge[200200];
inline void add_edge(int u,int to)//链式前向星加边 
{edge[++cnt].to=to;edge[cnt].next=head[u];head[u]=cnt;}
//-------------------------------------- 以下为线段树 
inline void pushdown(int p,int len)//下放懒标记 
{//右子树大小len>>1,左子树大小len-(len>>1) 
    lazy[L(p)]+=lazy[p];lazy[R(p)]+=lazy[p];
    a[L(p)]+=lazy[p]*(len-(len>>1));
    a[R(p)]+=lazy[p]*(len>>1);
    a[L(p)]%=mod;a[R(p)]%=mod;lazy[p]=0;
}
inline void bt(int p,int l,int r)//OK
{
    if(l==r) {a[p]=wt[l]%mod;return ;}
    int mid=(l+r)>>1;
    bt(L(p),l,mid);bt(R(p),mid+1,r);
    a[p]=(a[L(p)]+a[R(p)])%mod;
}
inline int ask(int p,int l,int r,int x,int y)
{//当前节点,左端点,右端点,查询左端点,查询右端点 
	if(x<=l&&r<=y) return a[p]%mod;
    if(lazy[p]) pushdown(p,r-l+1);
	int ans=0,mid=(l+r)>>1;
    if(x<=mid) ans+=ask(L(p),l,mid,x,y);
    if(y>mid) ans+=ask(R(p),mid+1,r,x,y);//
	return ans%mod;
}
inline void change(int p,int l,int r,int x,int y,int k)
{//当前节点,左端点,右端点,区间左端点,区间右端点,修改值 
    
	if(x<=l&&r<=y) {lazy[p]+=k,a[p]+=k*(r-l+1);return ;}
    if(lazy[p]) pushdown(p,r-l+1);
	int mid=(l+r)>>1;
    if(x<=mid) change(L(p),l,mid,x,y,k);
    if(y>mid) change(R(p),mid+1,r,x,y,k);
    a[p]=(a[L(p)]+a[R(p)])%mod;
}
//---------------------------------以上为线段树 
inline int ask_lu(int x,int y)
{
    int ans=0;
    while(top[x]!=top[y]) {//当两个点不在同一条链上 
    	//不妨令x为所在链顶端深度较深的点 
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        //ans加上top[x]到x这一段区间的点权和[ id[top[x],id[x] ] 
        ans+=ask(1,1,n,id[top[x]],id[x]);
        ans%=mod;//累加答案 
        x=fa[top[x]];//把x跳到x所在链顶端的那个点的上面一个点
    }//直到两个点处于一条链上 
    if(dep[x]>dep[y]) swap(x,y);//不妨令x为深度较浅的点 
    ans+=ask(1,1,n,id[x],id[y]);//这时再加上此时两个点的区间和即可 
    return ans%mod;
}
inline void change_lu(int x,int y,int z)//类似于ask_lu 
{
    while(top[x]!=top[y]) {
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        change(1,1,n,id[top[x]],id[x],z);
        x=fa[top[x]];
    }
    if(dep[x]>dep[y]) swap(x,y);
    change(1,1,n,id[x],id[y],z);
}
//子树区间右端点为id[x]+size[x]-1 !!! 
inline int ask_tr(int x) {return ask(1,1,n,id[x],id[x]+size[x]-1);}
//类似于ask_tr 
inline void change_tr(int x,int k) {change(1,1,n,id[x],id[x]+size[x]-1,k);}
inline void prepare(int u)
{//预处理每个子节点深度,父亲,子树大小(包括自己),重儿子编号 
	int maxson=-1;size[u]=1;//记录重儿子的儿子数 
	for(int i=head[u];i;i=edge[i].next) {
		int v=edge[i].to;
		if(fa[v]||v==root) continue;//已处理过则跳过 
		fa[v]=u;dep[v]=dep[u]+1;
		prepare(v);//处理子节点 
		size[u]+=size[v];//把它的儿子数加到它身上 
		if(size[v]>maxson) son[u]=v,maxson=size[v];//寻找重儿子 
	}
}
inline void dfs(int u,int topf)
{//x当前节点，topf当前链的最顶端的节点,OK 
    id[u]=++idx;//标记每个点的新编号,在线段树相关操作中用到 
    wt[idx]=w[u];//把每个点的初始值赋到新编号上来 
    top[u]=topf;//这个点所在链的顶端 
    if(!son[u]) return;//如果没有儿子则返回 
    dfs(son[u],topf);//按先处理重儿子，再处理轻儿子的顺序递归处理 
    for(int i=head[u];i;i=edge[i].next) {
        int v=edge[i].to;
        if(v==fa[u]||v==son[u]) continue;//已处理过重儿子 
        dfs(v,v);//对于每一个轻儿子都有一条从它自己开始的链 
    }
}
int main()
{
//	freopen("pou.in","r",stdin);
//	freopen("a.out","w",stdout);
    n=gint();m=gint();root=gint();mod=gint();
	for(int i=1;i<=n;i++) w[i]=gint();
    for(int i=1,u,v;i<n;i++) u=gint(),v=gint(),add_edge(u,v),add_edge(v,u);
	dep[root]=1;prepare(root);//预处理父亲,子树大小,重儿子信息 
    dfs(root,root);//将树分为链 
    bt(1,1,n);//在新建的链上进行线段树相关操作 
    while(m--) {
        int opt,x,y,z;opt=gint();
        if(opt==1) x=gint(),y=gint(),z=gint(),change_lu(x,y,z%mod);//修改路径上点权 
        else if(opt==2) x=gint(),y=gint(),printf("%d\n",ask_lu(x,y));//查询路径点权 
        else if(opt==3) x=gint(),y=gint(),change_tr(x,y);//修改单点子树点权 
        else x=gint(),printf("%d\n",ask_tr(x));//查询子树点权 
    }
    return 0;
}
#define pb push_back
#define lc o << 1
#define rc o << 1 | 1

const int maxn = 3e4 + 10;
const int inf = 1e9 + 10;

/*
son[x]：x的重儿子
top[x]：x所在重链的顶部节点
dfn[x]：x的DFS序，也是其在线段树中的编号
rnk[x]：DFS序所对应的节点编号，有rnk[dfn[x]]=x
*/
int n, a, b, w[maxn], q, u, v;
int siz[maxn], top[maxn], son[maxn], dep[maxn], fa[maxn], dfn[maxn], rnk[maxn], bottom[maxn], cnt;

struct SegTree {
  int sum[maxn * 4], maxx[maxn * 4];
  void build(int o, int l, int r) {
    if (l == r) {
      sum[o] = maxx[o] = w[rnk[l]];
      return;
    }
    int mid = (l + r) >> 1;
    build(lc, l, mid);
    build(rc, mid + 1, r);
    sum[o] = sum[lc] + sum[rc];
    maxx[o] = max(maxx[lc], maxx[rc]);
  }
  int query1(int o, int l, int r, int ql, int qr) {  // max
    if (l > qr || r < ql) return -inf;
    if (ql <= l && r <= qr) return maxx[o];
    int mid = (l + r) >> 1;
    return max(query1(lc, l, mid, ql, qr), query1(rc, mid + 1, r, ql, qr));
  }
  int query2(int o, int l, int r, int ql, int qr) {  // sum
    if (l > qr || r < ql) return 0;
    if (ql <= l && r <= qr) return sum[o];
    int mid = (l + r) >> 1;
    return query2(lc, l, mid, ql, qr) + query2(rc, mid + 1, r, ql, qr);
  }
  void update(int o, int l, int r, int x, int t) {
    if (l == r) {
      maxx[o] = sum[o] = t;
      return;
    }
    int mid = (l + r) >> 1;
    if (x <= mid)
      update(lc, l, mid, x, t);
    else
      update(rc, mid + 1, r, x, t);
    sum[o] = sum[lc] + sum[rc];
    maxx[o] = max(maxx[lc], maxx[rc]);
  }
} st;

vector<int> e[maxn];

/* 
Tree Build 
*/
int dfs1(int u, int d) { 
	dep[u] = d;
	siz[u] = 1;
	for (int v : e[u]) {
		if (v != fa[u]) {
			fa[v] = u;
			siz[u] += dfs1(v, d + 1);
			if (siz[v] > siz[son[u]]) {
				son[u] = v;
			}
		}
	}
	return siz[u];
}

/* 
Tree Decomposition
*/
void dfs2(int u, int t){
	top[u] = t;
	cnt++;
	dfn[u] = cnt;
	rnk[cnt] = u;
	if (son[u]) {
		dfs2(son[u], t);
		for (int v : e[u]) {
			if (v != fa[u] && v != son[u]) {
				dfs2(v, v);
			}
		}
	}
	bottom[u] = cnt;
}
/*
路径上维护：每次选择深度较大的链往上跳，直到两点在同一条链上。
*/
int querymax(int x, int y) {
	int ret = -inf, fx = top[x], fy = top[y];
	while (fx != fy) {
		if (dep[fx] >= dep[fy]) {
	  		ret = max(ret, st.query1(1, 1, n, dfn[fx], dfn[x]));
	  		x = fa[fx];
	  		fx = top[x];
		}
		else {
	  		ret = max(ret, st.query1(1, 1, n, dfn[fy], dfn[y]));
	  		y = fa[fy];
	  		fy = top[y];
	  	}
	}
	if (dfn[x] < dfn[y]) {
		ret = max(ret, st.query1(1, 1, n, dfn[x], dfn[y]));
	}
	else {
		ret = max(ret, st.query1(1, 1, n, dfn[y], dfn[x]));
	}
	return ret;
}

int querysum(int x, int y) {
	int ret = 0, fx = top[x], fy = top[y];
	while (fx != fy) {
		if (dep[fx] >= dep[fy]) {
	  		ret += st.query2(1, 1, n, dfn[fx], dfn[x]);
	  		x = fa[fx];
	  		fx = top[x];
		}
		else {
	  		ret += st.query2(1, 1, n, dfn[fy], dfn[y]);
	  		y = fa[fy];
	  		fy = top[y];
	  	}
	}
	if (dfn[x] < dfn[y]) {
		ret += st.query2(1, 1, n, dfn[x], dfn[y]);
	}
	else {
		ret += st.query2(1, 1, n, dfn[y], dfn[x]);
	}
	return ret;
}

int lca(int u, int v) {
  while (top[u] != top[v]) {
    if (dep[top[u]] > dep[top[v]])
      u = fa[top[u]];
    else
      v = fa[top[v]];
  }
  return dep[u] > dep[v] ? v : u;
}


void solve() {
	cin >> n;
	int u, v;
	for (int i = 1; i < n; i++) {
		cin >> u >> v;
		e[u].pb(v);
		e[v].pb(u);
	}
	for (int i = 1; i <= n; i++) {
		cin >> w[i];
	}
	dep[1] = 1;
	dfs1(1, 1);
	dfs2(1, 1);
	st.build(1, 1, n);
	cin >> q;
	string op;
	while (q--) {
		cin >> op;
		if (op == "CHANGE") {
			int u, t;
			cin >> u >> t;
			st.update(1, 1, n, dfn[u], t);
		} else if (op == "QMAX") {
			int u, v;
			cin >> u >> v;
			cout << querymax(u, v) << endl;
		} else {
			int u, v;
			cin >> u >> v;
			cout << querysum(u, v) << endl;
		}
	}
}
```

### 吉司机线段树

`1 l r k`：对所有的 $i\in[l,r]$ ，将 $A_i$ 加上 $k$

`2 l r v`：对于所有的 $i\in[l,r]$ ，将 $A_i$ 变成 $\min(A_i,v)$

`3 l r`：求 $\Sigma_{i=l}^r A_i$ 

`4 l r`：对于所有的 $i\in[l,r]$，求 $A_i$ 的最大值

`5 l r`：对于所有的 $i\in[l,r]$，求 $B_i$ 的最大值

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5,inf = 2e9;
struct Node{
	long long sum;
	int maxn,sec,cnt,hismax,tag1,tag2,tag3,tag4;
}t[N * 4];
int n,m;
inline void pushup(int pos)
{
	t[pos].sum = t[pos << 1].sum + t[pos << 1 | 1].sum;
	t[pos].maxn = max(t[pos << 1].maxn,t[pos << 1 | 1].maxn);
	t[pos].hismax = max(t[pos << 1].hismax,t[pos << 1 | 1].hismax);
	if(t[pos << 1].maxn == t[pos << 1 | 1].maxn) 
		t[pos].sec = max(t[pos << 1].sec,t[pos << 1 | 1].sec),t[pos].cnt = t[pos << 1].cnt + t[pos << 1 | 1].cnt;
	else if(t[pos << 1].maxn > t[pos << 1 | 1].maxn)
		t[pos].sec = max(t[pos << 1].sec,t[pos << 1 | 1].maxn),t[pos].cnt = t[pos << 1].cnt;
	else 
		t[pos].sec = max(t[pos << 1].maxn,t[pos << 1 | 1].sec),t[pos].cnt = t[pos << 1 | 1].cnt;
}
inline void change(int pos,int l,int r,int k1,int k2,int k3,int k4)
{
	t[pos].sum += 1ll * (r - l + 1 - t[pos].cnt) * k1 + 1ll * t[pos].cnt * k2;
	t[pos].hismax = max(t[pos].hismax,t[pos].maxn + k4);
	t[pos].maxn += k2;
	if(t[pos].sec != -inf) t[pos].sec += k1;
	t[pos].tag4 = max(t[pos].tag4,t[pos].tag2 + k4);
	t[pos].tag3 = max(t[pos].tag3,t[pos].tag1 + k3);
	t[pos].tag1 += k1;
	t[pos].tag2 += k2;
}
inline void pushdown(int pos,int l,int r)
{
	int mid = (l + r) >> 1;
	int mx = max(t[pos << 1].maxn,t[pos << 1 | 1].maxn);
	if(mx == t[pos << 1].maxn) change(pos << 1,l,mid,t[pos].tag1,t[pos].tag2,t[pos].tag3,t[pos].tag4);
	else change(pos << 1,l,mid,t[pos].tag1,t[pos].tag1,t[pos].tag3,t[pos].tag3);
	if(mx == t[pos << 1 | 1].maxn) change(pos << 1 | 1,mid + 1,r,t[pos].tag1,t[pos].tag2,t[pos].tag3,t[pos].tag4);
	else change(pos << 1 | 1,mid + 1,r,t[pos].tag1,t[pos].tag1,t[pos].tag3,t[pos].tag3);
	t[pos].tag1 = 0;
	t[pos].tag2 = 0;
	t[pos].tag3 = 0;
	t[pos].tag4 = 0;
}
inline void build(int l,int r,int pos)
{
	if(l == r)
	{
		cin>>t[pos].sum;
		t[pos].maxn = t[pos].sum;
		t[pos].hismax = t[pos].maxn;
		t[pos].sec = -inf;
		t[pos].tag1 = t[pos].tag2 = t[pos].tag3 = t[pos].tag4 = 0;
		t[pos].cnt = 1;
		return;
	}
	int mid = (l + r) >> 1;
	build(l,mid,pos << 1);
	build(mid + 1,r,pos << 1 | 1);
	pushup(pos);
}
inline void modify_add(int l,int r,int L,int R,int k,int pos)
{ 
	if(L <= l && r <= R)
	{
		t[pos].sum += 1ll * k * (r - l + 1 - t[pos].cnt) + 1ll * k * t[pos].cnt;
		t[pos].maxn += k;
		t[pos].hismax = max(t[pos].hismax,t[pos].maxn);
		if(t[pos].sec != -inf) t[pos].sec += k;
		t[pos].tag1 += k;t[pos].tag2 += k;
		t[pos].tag3 = max(t[pos].tag3,t[pos].tag1);
		t[pos].tag4 = max(t[pos].tag4,t[pos].tag2); 
		return;
	}
	pushdown(pos,l,r);
	int mid = (l + r) >> 1;
	if(L <= mid) modify_add(l,mid,L,R,k,pos << 1);
	if(R > mid) modify_add(mid + 1,r,L,R,k,pos << 1 | 1);
	pushup(pos);
}
inline void modify_min(int l,int r,int L,int R,int k,int pos)
{
	if(k >= t[pos].maxn) return;
	if(L <= l && r <= R && k > t[pos].sec)
	{
		t[pos].sum -= 1ll * t[pos].cnt * (t[pos].maxn - k);
		t[pos].tag2 -= t[pos].maxn - k;
		t[pos].maxn = k;
		return;
	}
	pushdown(pos,l,r);
	int mid = (l + r) >> 1;
	if(L <= mid) modify_min(l,mid,L,R,k,pos << 1);
	if(R > mid) modify_min(mid + 1,r,L,R,k,pos << 1 | 1);
	pushup(pos);
}
inline long long query_sum(int l,int r,int L,int R,int pos)
{
	if(L <= l && r <= R) return t[pos].sum;
	pushdown(pos,l,r);
	int mid = (l + r) >> 1;
	long long ret = 0;
	if(L <= mid) ret += query_sum(l,mid,L,R,pos << 1);
	if(R > mid) ret += query_sum(mid + 1,r,L,R,pos << 1 | 1);
	pushup(pos);
	return ret;
}
inline int query_max(int l,int r,int L,int R,int pos)
{
	if(L <= l && r <= R) return t[pos].maxn;
	pushdown(pos,l,r);
	int mid = (l + r) >> 1,ret = -inf;
	if(L <= mid) ret = max(ret,query_max(l,mid,L,R,pos << 1));
	if(R > mid) ret = max(ret,query_max(mid + 1,r,L,R,pos << 1 | 1));
	pushup(pos);
	return ret;
}
inline int query_hismax(int l,int r,int L,int R,int pos)
{
	if(L <= l && r <= R) return t[pos].hismax;
	pushdown(pos,l,r);
	int mid = (l + r) >> 1,ret = -inf;
	if(L <= mid) ret = max(ret,query_hismax(l,mid,L,R,pos << 1));
	if(R > mid) ret = max(ret,query_hismax(mid + 1,r,L,R,pos << 1 | 1));
	pushup(pos);
	return ret;
}
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	build(1,n,1);
	int op,l,r,k;
	for(int i = 1;i <= m;i++)
	{
		cin>>op>>l>>r;
		switch(op)
		{
			case 1:
				cin>>k;
				modify_add(1,n,l,r,k,1);
				break;
			case 2:
				cin>>k;
				modify_min(1,n,l,r,k,1);
				break;
			case 3:
				cout<<query_sum(1,n,l,r,1)<<endl;
				break;
			case 4:
				cout<<query_max(1,n,l,r,1)<<endl;
				break;
			case 5:
				cout<<query_hismax(1,n,l,r,1)<<endl;
				break;
		}
	}
	return 0;
}

```

### LCT

开至少两倍空间

给定 $n$ 个点以及每个点的权值，要你处理接下来的 $m$ 个操作。 

操作有四种，操作从 $0$ 到 $3$ 编号。点从 $1$ 到 $n$ 编号。


- `0 x y` 代表询问从 $x$ 到 $y$ 的路径上的点的权值的 $\text{xor}$ 和。保证 $x$ 到 $y$ 是联通的。
- `1 x y` 代表连接 $x$ 到 $y$，若 $x$ 到 $y$ 已经联通则无需连接。
- `2 x y` 代表删除边 $(x,y)$，不保证边 $(x,y)$ 存在。
- `3 x y` 代表将点 $x$ 上的权值变成 $y$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+10,maxm=1e5+10;
inline int gint() {
	char ch=getchar();int s=0,f=1;
	while(!isdigit(ch)) {if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) {s=(s<<3)+(s<<1)+(ch^48);ch=getchar();}
	return s*f;
}
int n,m,v[maxn];
int top,st[maxn];
struct Tree{
	int f,ch[2],maxx,id,r;
} tr[maxn];
int cnt,w[maxn],ans;
inline bool Not_Root(int x) {
	return tr[tr[x].f].ch[0]==x||tr[tr[x].f].ch[1]==x;
}
inline void Pushup(int x) {
	tr[x].maxx=w[x];tr[x].id=x;
	if(tr[tr[x].ch[0]].maxx>tr[x].maxx) 
		tr[x].maxx=tr[tr[x].ch[0]].maxx,tr[x].id=tr[tr[x].ch[0]].id;
	if(tr[tr[x].ch[1]].maxx>tr[x].maxx) 
		tr[x].maxx=tr[tr[x].ch[1]].maxx,tr[x].id=tr[tr[x].ch[1]].id;
}
inline void Reverse(int x) {
	swap(tr[x].ch[0],tr[x].ch[1]);
	tr[x].r^=1;
}
inline void Pushdown(int x) {
	if(!tr[x].r) return ;
	if(tr[x].ch[0]) Reverse(tr[x].ch[0]);
	if(tr[x].ch[1]) Reverse(tr[x].ch[1]);
	tr[x].r=0;
}
inline void Rotate(int x) {
	int y=tr[x].f,z=tr[y].f,k=tr[y].ch[1]==x,w=tr[x].ch[!k];
	if(Not_Root(y)) tr[z].ch[tr[z].ch[1]==y]=x;
	tr[x].ch[!k]=y;tr[y].ch[k]=w;
	if(w) tr[w].f=y;
	tr[y].f=x;tr[x].f=z;
	Pushup(y);
}
inline void Splay(int x) {
	int y=x;top=0;st[++top]=y;
	while(Not_Root(y)) st[++top]=tr[y].f,y=tr[y].f;
	while(top) Pushdown(st[top--]);
	while(Not_Root(x)) {
		y=tr[x].f;int z=tr[y].f;
		if(Not_Root(y))
			Rotate((tr[y].ch[0]==x)^(tr[z].ch[0]==y)?x:y);
		Rotate(x);
	}
	Pushup(x);
}
inline void Access(int x) {
	for(int y=0;x;y=x,x=tr[x].f)
		Splay(x),tr[x].ch[1]=y,Pushup(x);
}
inline void Makeroot(int x) {
	Access(x);Splay(x);Reverse(x);
}
inline int Findroot(int x) {
	Access(x);Splay(x);
	while(tr[x].ch[0]) Pushdown(x),x=tr[x].ch[0];
	Splay(x);
	return x;
}
inline void Split(int x,int y) {
	Makeroot(x);Access(y);Splay(y);
}
inline void Link(int x,int y) {
	Makeroot(x);
	if(Findroot(y)!=x) tr[x].f=y;
}
inline bool Is_Link(int x,int y) {
	Makeroot(x);
	return Findroot(y)==x;
}
inline void Cut(int x,int y) {
	Makeroot(x);
	if(Findroot(y)==x&&tr[y].f==x&&!tr[y].ch[0]) {
		tr[y].f=tr[x].ch[1]=0;
		Pushup(x);
	}
}
struct Edge{int x,y,a,b;} e[maxm];
inline bool cmp(Edge c,Edge d) {return c.a<d.a;}
int main() {
	n=gint();m=gint();cnt=n;ans=2e9;
	for(int i=1;i<=m;i++)
		e[i]={gint(),gint(),gint(),gint()};
	sort(e+1,e+m+1,cmp);
	for(int i=1;i<=m;i++) {
		w[++cnt]=e[i].b;
		if(Is_Link(e[i].x,e[i].y)) {
			Split(e[i].x,e[i].y);
			if(e[i].b>=tr[e[i].y].maxx) continue;
			int tmp=tr[e[i].y].id;
			Splay(tmp);
			tr[tr[tmp].ch[0]].f=tr[tr[tmp].ch[1]].f=0;
			Link(e[i].x,cnt);Link(cnt,e[i].y);
		}
		else {
			Link(e[i].x,cnt);Link(e[i].y,cnt);
		}
		if(Is_Link(1,n)) Split(1,n),ans=min(ans,e[i].a+tr[n].maxx);
	}
	printf("%d\n",ans==2e9?-1:ans);
	return 0;
}
```



### ST表

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10; 
int n,m,l,r,x,a[maxn],f[maxn][20],po[20]={1},Log[maxn];
inline int gint() {
	char ch=getchar();int s=0,f=1;
	while(!isdigit(ch)) {if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) {s=(s<<3)+(s<<1)+(ch^48);ch=getchar();}
	return s*f;
}
inline int query(int l,int r) {
	if(l>r) return 0;
	return max(f[l][Log[r-l+1]],f[r-po[Log[r-l+1]]+1][Log[r-l+1]]);
}
int main() {
	n=gint();m=gint();
	for(int i=1;i<=n;i++) f[i][0]=gint();
    for(int i=2;i<=n;i++) Log[i]=Log[i>>1]+1;
	for(int i=1;i<=17;i++) po[i]=po[i-1]<<1;
    for(int j=1;j<=17;j++) for(int i=1;i<=n-po[j]+1;i++) 
		f[i][j]=max(f[i][j-1],f[i+po[j-1]][j-1]);
    for(int i=1,l,r;i<=m;i++) l=gint(),r=gint(),printf("%d\n",query(l,r)); 
    return 0;
}
```

### unordered_map

```cpp
struct custom_hash {
	static uint64_t splitmix64(uint64_t x) {
		x+=0x9e3779b97f4a7c15;
		x=(x^(x>>30))*0xbf58476d1ce4e5b9;
		x=(x^(x>>27))*0x94d049bb133111eb;
		return x^(x>>31);
	}
	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM=chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};
unordered_map<int, int, custom_hash> safe_map;

```

## 图论

### 树的哈希

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int maxn=2e5+10;
int T,n,cnt,head[maxn];
struct Edge{int to,nex;} e[maxn<<1];
inline void add(int u,int to) {
	e[++cnt].to=to;e[cnt].nex=head[u];head[u]=cnt;
}
inline int gint() {
	int ff=1,ee=0;char ss=getchar();
	while((ss<'0'||ss>'9')&&ss!='-') ss=getchar();
	while((ss>='0'&&ss<='9')||ss=='-') 
	{if(ss=='-') ff=-1;else ee=(ee<<1)+(ee<<3)+ss-'0';ss=getchar();}
	return ee*ff;
}
const ull mask=chrono::steady_clock::now().time_since_epoch().count();
inline ull shift(ull x) {
	x^=mask;x^=x<<13;
	x^=x>>7;x^=x<<17;
	x^=mask;
	return x;
}
ull f[maxn];
set<ull> trees;
inline void getHash(int u, int p) {
	vector<int> ve;
	f[u]=1;
	for(int i=head[u];i;i=e[i].nex) {
		int v=e[i].to;
		if(v==p) continue;
		getHash(v,u);
		f[u]+=shift(f[v]);
	}
	trees.insert(f[u]);
}
int main() {
	T=gint();
	while(T--) {
		n=gint();cnt=0;trees.clear();
		for(int i=1;i<=n;i++) head[i]=0,f[i]=0;
		for(int i=1,x,y;i<n;i++) {
			x=gint();y=gint();
			add(x,y);add(y,x);
		}
		getHash(1,-1);
	}
	return 0;
}
```



### 堆优化Dijkstra

```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=2e9;
const int maxn=1e5+10,maxm=2e5+10;
struct edge{int nex,v,w;} e[maxm<<1];
int cnt,head[maxn],u,v,w,n,m,s,t;
inline void add(int u,int v,int w) {
	e[++cnt].v=v;e[cnt].w=w;
	e[cnt].nex=head[u];head[u]=cnt;
}
struct Heapnode{
	int u,d;
	bool operator<(const Heapnode & rhs) const {
		return d>rhs.d;
	}
};
int main() {
    scanf("%d%d%d",&n,&m,&s);
    for(int z=1;z<=m;++z){
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,w);
    }
	int d[maxn];
	priority_queue<Heapnode> q;
	for(int z=1;z<=n;++z) d[z]=INF;
    d[s]=0;
    q.push((Heapnode){s,d[s]});
    while(!q.empty()) {
        Heapnode x=q.top();q.pop();
        int u=x.u;
        if(x.d!=d[u]) continue;
        for(int z=head[u];z;z=e[z].nex) {
            int v=e[z].v,w=e[z].w;
            if(d[u]+w<d[v]){
                d[v]=d[u]+w;
                q.push((Heapnode){v,d[v]});
            }
        }
    }
    for(int i=1;i<=n;i++) printf("%d ",d[i]);
    return 0;
}
```

### 点双联通分量

点双连通分量中，去掉任何一个点，都不会改变该剩余连通分量的连通性，即不存在割点（孤立点也是）

该程序输出所有点双连通分量

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5, M = 4e6 + 5;
int cnt = 1, fir[N], nxt[M], to[M];
int s[M], top, bcc, low[N], dfn[N], idx, n, m;
vector<int> ans[N];
inline void tarjan(int u, int fa) {
	int son = 0;
	low[u] = dfn[u] = ++idx;
	s[++top] = u;
	for(int i = fir[u]; i; i = nxt[i]) {
		int v = to[i];
		if(!dfn[v]) {
			son++;
			tarjan(v, u);
			low[u] = min(low[u], low[v]);
			if(low[v] >= dfn[u]) {
				bcc++;
				while(s[top + 1] != v) ans[bcc].push_back(s[top--]);//将子树出栈
				ans[bcc].push_back(u);//把割点/树根也丢到点双里
			}
		} else if(v != fa) low[u] = min(low[u], dfn[v]);
	}
	if(fa == 0 && son == 0) ans[++bcc].push_back(u);//特判独立点
}
inline void add(int u, int v) {
	to[++cnt] = v;
	nxt[cnt] = fir[u];
	fir[u] = cnt;
}
int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; i++) {
		int u, v;
		scanf("%d%d", &u, &v);
		add(u, v), add(v, u);
	}
	for(int i = 1; i <= n; i++) {
		if(dfn[i]) continue;
		top = 0;
		tarjan(i, 0);
	}
	printf("%d\n", bcc);
	for(int i = 1; i <= bcc; i++) {
		printf("%d ", ans[i].size());
		for(int j : ans[i]) printf("%d ", j);
		printf("\n");
	}
	return 0;
}
```

### 割点

输出所有割点

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,idx,tot,cnt,head[20200];
int dfn[20200],low[20200];
bool cut[20200];
struct Edge{int to,next;} edge[200200];
inline void add_edge(int u,int to)
{edge[++cnt].to=to;edge[cnt].next=head[u];head[u]=cnt;}
inline void tarjan(int u,int fa)
{
	dfn[u]=low[u]=++idx;
	int sum_h=0;//个人认为可以理解为u所在环数 
	for(int i=head[u];i;i=edge[i].next) {
		int v=edge[i].to;
		if(!dfn[v]) {//没有到达过v 
			tarjan(v,fa);//处理v 
			low[u]=min(low[u],low[v]);//更新从u能到达的最早的点 
			//若u为非根节点,并且从v无法到达比u更早的点 
			if(low[v]>=dfn[u]&&u!=fa) cut[u]=1;//则u一定为割点 
			if(u==fa) sum_h++;//环数+1 
		}
		low[u]=min(low[u],dfn[v]);//千万注意是dfn[v],对于无向图求割点不能是low[v] 
	}
	if(sum_h>=2&&u==fa) cut[u]=1;//对于每个根节点,若处于多个环中,
	//割掉u必定使多个环不连通,u一定是割点 
}
int main()
{
//	freopen("a.in","r",stdin);
	scanf("%d%d",&n,&m);
	for(int i=1,x,y;i<=m;i++) scanf("%d%d",&x,&y),add_edge(x,y),add_edge(y,x);
	for(int i=1;i<=n;i++)//防止不是连通图,故以每个点为根遍历一遍 
		if(!dfn[i]) tarjan(i,i);
	for(int i=1;i<=n;i++) if(cut[i]) tot++;printf("%d\n",tot);
	for(int i=1;i<=n;i++) if(cut[i]) printf("%d ",i);
    return 0;
}
//附:造数据程序: 
//#include<bits/stdc++.h>
//using namespace std;
//int n,m,s;
//int mp[2000][2000];
//int main()
//{
//	freopen("a.in","w",stdout);
//	n=100;m=200;
//	srand(time(NULL));
//	while(s<m) {
//		int x=rand()%n+1,y=rand()%n+1;
//		if(!mp[x][y]&&!mp[y][x]&&x!=y) mp[x][y]=mp[y][x]=1,s++,printf("%d %d\n",x,y);
//	}
//	return 0;
//}

```

### 边双连通分量

边双连通分量中，去掉任何一条边，原图的连通性不变，即不存在割边（桥）（孤立点也算边双连通分量）

输出所有边双连通分量

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
const int maxn = 500010, maxm = 4000010;
int n, m, cnt = 1, ans, id;
int dfn[maxn], low[maxn], head[maxn], dcc[maxn];
struct edge
{
	int to, nxt;
}e[maxm];
bool b[maxm];
vector <vector <int> > Ans;
void add(int f, int t)
{
	e[++cnt].to = t;
	e[cnt].nxt = head[f];
	head[f] = cnt;
}
void tarjan(int node, int in_edge)
{
	dfn[node] = low[node] = ++id;
	for (int i = head[node]; i; i = e[i].nxt)
	{
		const int to = e[i].to;
		if (dfn[to] == 0)
		{
			tarjan(to, i);
			if (dfn[node] < low[to])
				b[i] = b[i ^ 1] = 1;
			low[node] = min(low[node], low[to]);
		}
		else if (i != (in_edge ^ 1))
			low[node] = min(low[node], dfn[to]);
	}
}
void dfs(int node, int ndcc)
{
	dcc[node] = ndcc;
	Ans[ndcc - 1].push_back(node);
	for (int i = head[node]; i; i = e[i].nxt)
	{
		int to = e[i].to;
		if (dcc[to] || b[i]) continue;
		dfs(to, ndcc);
	}
}
int main()
{
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= m; ++i)
	{
		int f, t;
		scanf("%d %d", &f, &t);
		if (f == t) continue;
		add(f, t);
		add(t, f);
	}
	for (int i = 1; i <= n; ++i)
		if (dfn[i] == 0)
			tarjan(i, 0);
	for (int i = 1; i <= n; ++i)
		if (dcc[i] == 0)
		{
			Ans.push_back(vector <int>());
			dfs(i, ++ans);
		}
	printf("%d\n", ans);
	for (int i = 0; i < ans; ++i)
	{
		printf("%d", Ans[i].size());
		for (int j = 0; j < Ans[i].size(); ++j)
			printf(" %d", Ans[i][j]);
		printf("\n");
	}
	return 0;
}
```

### 割边

```cpp
int low[MAXN], dfn[MAXN], dfs_clock;
bool isbridge[MAXN];
vector<int> G[MAXN];
int cnt_bridge;
int father[MAXN];

void tarjan(int u, int fa) {
  father[u] = fa;
  low[u] = dfn[u] = ++dfs_clock;
  for (int i = 0; i < G[u].size(); i++) {
    int v = G[u][i];
    if (!dfn[v]) {
      tarjan(v, u);
      low[u] = min(low[u], low[v]);
      if (low[v] > dfn[u]) {
        isbridge[v] = true;
        ++cnt_bridge;
      }
    } else if (dfn[v] < dfn[u] && v != fa) {
      low[u] = min(low[u], dfn[v]);
    }
  }
}
```

### 强连通分量

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10,maxm=1e6+10;
int n,m,x,ans,idx,w[maxn],nw[maxn],dfn[maxn],low[maxn];
int cnt,head[maxn];
struct Edge{int to,nex;} e[maxm];
inline void add(int u,int to) {
	e[++cnt].to=to;e[cnt].nex=head[u];head[u]=cnt;
}
int tot,id[maxn];
stack<int> s;
bool ins[maxn];
inline void tarjan(int u) {
    dfn[u]=low[u]=++idx;
    s.push(u);ins[u]=1;
    for(int i=head[u];i;i=e[i].nex) {
        int v=e[i].to;
        if(!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]);
        else if(ins[v]) low[u]=min(low[u],dfn[v]);
    }
    if(low[u]==dfn[u]) {
		tot++;
        while(s.top()!=u) {
            nw[tot]+=w[s.top()];
            id[s.top()]=tot;
            ins[s.top()]=0;
            s.pop();
        }
        nw[tot]+=w[s.top()];
        id[s.top()]=tot;ins[s.top()]=0;s.pop(); 
    }
}
inline int gint() {
    int ff=1,ee=0;char ss=getchar();
    while(ss<'0'||ss>'9') ss=getchar();
    while(ss>='0'&&ss<='9') {ee=(ee<<1)+(ee<<3)+(ss^48);ss=getchar();}
    return ee*ff;
}
int main() {
    n=gint();m=gint();
    for(int i=1;i<=n;i++) w[i]=gint();
    for(int i=1,u,v;i<=m;i++) u=gint(),v=gint(),add(u,v);
    for(int i=1;i<=n;i++) if(!dfn[i]) tarjan(i);
	return 0;
}
```

### 三/四元环计数

```cpp
/* */

#include <bits/stdc++.h>
using namespace std;

int n, m;

struct Edge {
  int to, nxt;
} edge[500];

int cntEdge, head[20];

void addEdge(int u, int v) {
  edge[++cntEdge] = {v, head[u]}, head[u] = cntEdge;
}

long long answer, dp[1 << 19][20];

int main() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= m; i++) {
    int u, v;
    scanf("%d%d", &u, &v);
    addEdge(u, v);
    addEdge(v, u);
  }
  for (int i = 1; i <= n; i++) dp[1 << i - 1][i] = 1;
  for (int s = 1; s < (1 << n); s++)
    for (int i = 1; i <= n; i++) {
      if (!dp[s][i]) continue;
      for (int j = head[i]; j; j = edge[j].nxt) {
        int u = i, v = edge[j].to;
        if ((s & -s) > (1 << v - 1)) continue;
        if (s & (1 << v - 1)) {
          if ((s & -s) == (1 << v - 1)) answer += dp[s][u];
        } else
          dp[s | (1 << v - 1)][v] += dp[s][u];
      }
    }
  printf("%lld\n", (answer - m) / 2);
  return 0;
}
/* 三元环 */
#include <bits/stdc++.h>
using namespace std;

int n, m, total;
int deg[200001], u[200001], v[200001];
bool vis[200001];

struct Edge {
  int to, nxt;
} edge[200001];

int cntEdge, head[100001];

void addEdge(int u, int v) {
  edge[++cntEdge] = {v, head[u]}, head[u] = cntEdge;
}

int main() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= m; i++)
    scanf("%d%d", u + i, v + i), deg[u[i]]++, deg[v[i]]++;
  for (int i = 1; i <= m; i++) {
    if ((deg[u[i]] == deg[v[i]] && u[i] > v[i]) || deg[u[i]] < deg[v[i]])
      swap(u[i], v[i]);
    addEdge(u[i], v[i]);
  }
  for (int u = 1; u <= n; u++) {
    for (int i = head[u]; i; i = edge[i].nxt) vis[edge[i].to] = true;
    for (int i = head[u]; i; i = edge[i].nxt) {
      int v = edge[i].to;
      for (int j = head[v]; j; j = edge[j].nxt) {
        int w = edge[j].to;
        if (vis[w]) total++;
      }
    }
    for (int i = head[u]; i; i = edge[i].nxt) vis[edge[i].to] = false;
  }
  printf("%d\n", total);
  return 0;
}
/* 四元环 */
#include <bits/stdc++.h>
using namespace std;

int n, m, deg[100001], cnt[100001];
vector<int> E[100001], E1[100001];

long long total;

int main() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= m; i++) {
    int u, v;
    scanf("%d%d", &u, &v);
    E[u].push_back(v);
    E[v].push_back(u);
    deg[u]++, deg[v]++;
  }
  for (int u = 1; u <= n; u++)
    for (int v : E[u])
      if (deg[u] > deg[v] || (deg[u] == deg[v] && u > v)) E1[u].push_back(v);
  for (int a = 1; a <= n; a++) {
    for (int b : E1[a])
      for (int c : E[b]) {
        if (deg[a] < deg[c] || (deg[a] == deg[c] && a <= c)) continue;
        total += cnt[c]++;
      }
    for (int b : E1[a])
      for (int c : E[b]) cnt[c] = 0;
  }
  printf("%lld\n", total);
  return 0;
}
```

### 匈牙利算法

$\Theta(NM)$求二分图匹配，输入为 $n,m,t$ ，以及 $t$ 条形如 $(x,y,z)$ 的边

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1005;
int n,m,t,mch[maxn],vistime[maxn];
vector<int> e[maxn];
inline bool dfs(int u,int tag) {
	if(vistime[u]==tag) return false;
	vistime[u]=tag;
	for(auto v : e[u]) if((mch[v]==0)||dfs(mch[v],tag)) {
		mch[v]=u;
		return true;
	}
	return false;
}
int main() {
	scanf("%d%d%d",&n,&m,&t);
	for(int i=1,u,v;i<=t;i++) {
		scanf("%d%d",&u,&v);
		e[u].push_back(v);
	}
	int ans=0;
	for(int i=1;i<=n;i++) if(dfs(i,i)) ans++;
	printf("%d\n",ans);
}
```

### KM算法

输入为 $n,m$ 及 $n\times m$ 的一个矩阵，复杂度 $O(N^3)$

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm> 
using namespace std;
const int MAX_X = 1024;
const int MAX_Y = 1024;
 
int n, m;                        // X ,Y 的大小
int weight[MAX_X][MAX_Y];        // X 到 Y 的映射（权重）
int lx[MAX_X], ly[MAX_Y];        // 标号
bool sx[MAX_X], sy[MAX_Y];      // 是否被搜索过
int match[MAX_Y];              // Y(i) 与 X(match [i]) 匹配
 
void init(){
    for(int i = 0; i < n; i ++)
        for(int j = 0; j < m; j ++)
            scanf("%d", &weight[i][j]);
}
 
//寻找增广路径
bool hungary(int u){   
    sx[u] = true;
    for(int v = 0; v < m; v ++)
        if(!sy [v] && lx[u] + ly[v] == weight[u][v]){
            sy[v] = true;
            if(match[v] == -1 || hungary(match[v])){
                match [v] = u;
                return true;
            }
        }
    return false;
}
 
int KM(bool maxsum){ // 参数 maxsum 为 true ，返回最大权匹配，否则最小权匹配
    int i, j;
    if(!maxsum){
        for(i = 0; i < n; i ++)
            for(j = 0; j < m; j ++)
                weight [i] [j] = -weight [i] [j];
    }
    
    // 初始化标号
    memset(ly, 0, sizeof(ly));
    for(i = 0; i < n; i ++){
        lx[i] = -0x7FFFFFFF;
        for(j = 0; j < m; j ++)
            lx[i] = max(weight[i][j], lx[i]);
    }
 
    memset(match, -1, sizeof(match));
    for(int u = 0; u < n; u ++){
        while(1){
            memset(sx, 0, sizeof(sx));
            memset(sy, 0, sizeof(sy));
            if(hungary(u))   break;
            // 修改标号
            int d = 0x7FFFFFFF;
            for(i = 0; i < n; i++)
                if(sx[i])
                    for(j = 0; j < m; j ++)
                        if(!sy[j])
                            d = min(lx[i] + ly[j] - weight[i][j], d);
            for(i = 0; i < n; i ++)  if(sx[i])   lx[i] -= d;
            for(i = 0; i < m; i ++)  if(sy[i])   ly[i] += d;
            
        }
    }
    int sum = 0;
    for(i = 0; i < m; i ++)
        sum += weight[ match[i] ][i];
    if(!maxsum){
        sum = -sum;
        for(i = 0; i < n; i ++)
            for(j = 0; j < m; j ++)
                weight[i][j] = -weight[i][j];         // 如果需要保持 weight [ ] [ ] 原来的值，这里需要将其还原
    }
    return sum;
}
 
int main(){
    while(~scanf("%d %d", &n, &m)){
        init();
        printf("%d\n", KM(false));
        for(int i = 0; i < m; i ++)
            printf("X %d -> Y %d\n", match [i], i);
    }
    return 0;
}
```

### 带花树

一般图最大匹配：给定n个点m条边，求问有多少匹配，复杂度 $O(N^3)$ ，实际很松，约为 $O(N^2)$ ？

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int T,n,m,idx,cnt,ans,head[N],f[N],match[N],pre[N],vis[N],dfn[N];
queue<int>q;
struct Edge{int to,nex;} e[N*N];
inline int gint() {
	char ch=getchar();int s=0,f=1;
	while(!isdigit(ch)) {if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) {s=(s<<3)+(s<<1)+(ch^48);ch=getchar();}
	return s*f;
}
inline void add(int u,int v) {e[++cnt]={v,head[u]};head[u]=cnt;}
inline int fa(int x) {return x==f[x]?x:f[x]=fa(f[x]);}
inline int lca(int u,int v) {
	++idx;u=fa(u);v=fa(v);
	for(;dfn[u]!=idx;){
		dfn[u]=idx;
		u=fa(pre[match[u]]);
		if(v)swap(u,v);
	}
	return u;
}
inline void blossom(int x,int y,int w) {
	while(fa(x)!=w) {
		pre[x]=y,y=match[x];
		if(vis[y]==2) vis[y]=1,q.push(y);
		if(fa(x)==x) f[x]=w;
		if(fa(y)==y) f[y]=w;
		x=pre[y];
	} 
} 
inline int aug(int s){
	if((ans+1)*2>n) return 0;
	for(int i=1;i<=n;++i) f[i]=i,vis[i]=pre[i]=0;
	while(!q.empty()) q.pop();
	q.push(s);vis[s]=1;
	while(!q.empty()) {
		int u=q.front(),w;q.pop();
		for(int i=head[u];i;i=e[i].nex){
			int v=e[i].to;
			if(fa(u)==fa(v)||vis[v]==2) continue;
			if(!vis[v]) {
				vis[v]=2;pre[v]=u;
				if(!match[v]) {
					for(int x=v,las;x;x=las)las=match[pre[x]],match[x]=pre[x],match[pre[x]]=x;
					return 1;
				}
				vis[match[v]]=1,q.push(match[v]);
			}
			else blossom(u,v,w=lca(u,v)),blossom(v,u,w);
		}
	}
	return 0;
}
int main() {
	n=gint();m=gint();
	for(int i=1,u,v;i<=m;i++) u=gint(),v=gint(),add(u,v),add(v,u);
	for(int i=n;i;--i) if(!match[i])ans+=aug(i);
	printf("%d\n",ans);
	for(int i=1;i<=n;i++) printf("%d ",match[i]);
	return 0;
}
```

### 最大流

Dinic 当前弧优化，复杂度 $O(n^2m)$ 

对于边权均为1的图复杂度为 $O(m\min\{m^{\frac12},n^{\frac23}\})$ ，貌似也就 $O(n^\frac53)$ 

对于除源汇点外边权均为1的图复杂度为 $O(m\sqrt n)$ 

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e4+10,maxm=1e5+10,INF=0x7f7f7f7f;
int n,m,s,t,a,ans,tmp,cnt=-1,head[maxn],dis[maxn],cur[maxn];
struct Edge{int w,to,nex;} e[maxm<<1];
inline void add(int u,int to,int w) {e[++cnt]=(Edge){w,to,head[u]};head[u]=cnt;}
inline int gint() {
	char ch=getchar();int s=0,f=1;
	while(!isdigit(ch)) {if (ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) {s=(s<<3)+(s<<1)+ch-'0';ch=getchar();}
	return s*f;
}
queue<int> q;
inline bool bfs() {
	memset(dis,0,sizeof dis);dis[s]=1;q.push(s);
	for(int i=1;i<=n;i++) cur[i]=head[i];//注意n应为最大点编号
	while(q.size()) {
		int u=q.front();q.pop();
		for(int i=head[u];i!=-1;i=e[i].nex) {
			int v=e[i].to;if(!dis[v]&&e[i].w>0) dis[v]=dis[u]+1,q.push(v);
		}
	}
	return dis[t];
}
inline int dfs(int u,int low) {
	if(u==t) return low;
	for(int &i=cur[u];i!=-1;i=e[i].nex) {
		int v=e[i].to;
		if(dis[v]==dis[u]+1&&e[i].w&&(a=dfs(v,min(low,e[i].w)))) {
			return e[i].w-=a,e[i^1].w+=a,a;
		}
	}
	return 0;
}
int main() {
	n=gint();m=gint();s=gint();t=gint();memset(head,0xff,sizeof head);
	for(int i=1,x,y,z;i<=m;i++) x=gint(),y=gint(),z=gint(),add(x,y,z),add(y,x,0);
	while(bfs()) while((tmp=dfs(s,INF))) ans+=tmp;
	printf("%d",ans);
	return 0;
}

```

以下是通过对边的合并加速，复杂度 $O(nm\log w)$ 

```cpp
#include<bits/stdc++.h>
#define maxn 1300
#define maxm 120010
using namespace std;
struct edge{
	int u,v,cap;
}e[maxm];
struct Dinic{
	int tp,s,t,dis[maxn],cur[maxn],que[maxn];
	vector<edge>e;vector<int>v[maxn];
	void AddEdge(int x,int y,int flw){
		e.push_back(edge{x,y,flw});
		e.push_back(edge{y,x,0});
		v[x].push_back(e.size()-2);
		//v[y].push_back(e.size()-1);
	}
	int bfs(){
		memset(dis,0x3f,sizeof dis);
		int l=1,r=1;que[1]=s;dis[s]=0;
		while(l<=r){
			int p=que[l++],to;
			for(int i:v[p])if(e[i].cap && dis[to=e[i].v]>1e9)
				dis[to]=dis[p]+1,que[++r]=to;
		}
		return dis[t]<1e9;
	}
	int dfs(int p,int a){
		if(p==t || !a)return a;
		int sf=0,flw;
		for(int &i=cur[p],to;i<(int)v[p].size();++i){
			edge &E=e[v[p][i]];
			if(dis[to=E.v]==dis[p]+1 && (flw=dfs(to,min(a,E.cap)))){
				E.cap-=flw;e[v[p][i]^1].cap+=flw;
				a-=flw;sf+=flw;
				if(!a)break;
			}
		}
		return sf;
	}
	int dinic(int s,int t,int tp=1){
		this->s=s;this->t=t;this->tp=tp;
		int flw=0;
		while(bfs()){
			memset(cur,0,sizeof cur);
			flw+=dfs(s,INT_MAX);
		}
		return flw;
	}
}sol;
int n,m,i,s,t,ans;
int main(){
	scanf("%d%d%d%d",&n,&m,&s,&t);
	for(i=0;i<m;i++)scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].cap);
	sort(e,e+m,[](edge a,edge b){return a.cap>b.cap;});
	for(int tp:{0,1})for(int p=1<<30,i=0;p;p/=2){
		while(i<m && e[i].cap>=p){
			if(tp)sol.v[e[i].v].push_back(i*2+1);
			else sol.AddEdge(e[i].u,e[i].v,e[i].cap);
			i++;
		}
		ans+=sol.dinic(s,t,tp);
	}
	printf("%d\n",ans);
	return 0;
}

```

### 最小费用最大流

复杂度上界 $O(n^2m^2)$ ，实际上在数据随机的情况下是可以通过洛谷模板题 $n\le 5e3,m\le 5e4$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100010;
bool b[maxn];
int n,m,s,t,dis[maxn],pre[maxn],las[maxn],flow[maxn],maxflow,mincost;
struct Edge{int to,nex,w,dis;} e[maxn];
int head[maxn],cnt=-1;
queue<int> q;
inline void add(int from,int to,int w,int dis) {
    e[++cnt].nex=head[from];e[cnt].to=to;
    e[cnt].w=w;e[cnt].dis=dis;head[from]=cnt;
}
inline bool spfa(int s,int t) {
    memset(dis,0x7f,sizeof(dis));flow[s]=1<<29;//memset(flow,0x7f,sizeof(flow));
    memset(b,0,sizeof(b));q.push(s);b[s]=1;dis[s]=0;pre[t]=-1;
    while(!q.empty()) {
        int u=q.front();q.pop();b[u]=0;
        for(int i=head[u];i!=-1;i=e[i].nex) { 
            if(e[i].w>0&&dis[e[i].to]>dis[u]+e[i].dis) {
                dis[e[i].to]=dis[u]+e[i].dis;
                pre[e[i].to]=u;
                las[e[i].to]=i; 
                flow[e[i].to]=min(flow[u],e[i].w);
                if(!b[e[i].to])
                    b[e[i].to]=1,q.push(e[i].to);
            }
        }
    }
    if(pre[t]!=-1) return 1;return 0;
}
int main() {
    memset(head,-1,sizeof(head));
    scanf("%d%d%d%d",&n,&m,&s,&t);
    for(int i=1,x,y,z,f;i<=m;i++) {
        scanf("%d%d%d%d",&x,&y,&z,&f);
        add(x,y,z,f);add(y,x,0,-f);
    }
    while(spfa(s,t)) {
        int now=t;
        maxflow+=flow[t];mincost+=flow[t]*dis[t];
        while(now!=s) {
            e[las[now]].w-=flow[t];
            e[las[now]^1].w+=flow[t];
            now=pre[now];
        }
    }
    printf("%d %d",maxflow,mincost);
    return 0;
}
//Dijkstra费用流,好像会更快
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e3+10,maxm=1e5+10,INF=1<<29;
int n,m,s,t,cnt=-1,head[maxn],min_cost,max_flow;
int dis[maxn],flow[maxn],pre[maxn],vis[maxn],h[maxn];
struct Edge{int to,nex,w,d;} e[maxm];
inline void add(int u,int to,int w,int d) {
	e[++cnt].to=to;e[cnt].w=w;e[cnt].d=d;
	e[cnt].nex=head[u];head[u]=cnt;
}
priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;
inline bool Dij(int s,int t) {
	for(int i=1;i<=n;i++) dis[i]=INF,vis[i]=0;
	q.push(make_pair(0,s));
	flow[s]=INF;dis[s]=0;
	while(q.size()) {
		int u=q.top().second;q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(register int i=head[u];~i;i=e[i].nex) {
			int v=e[i].to;
			if(e[i].w>0&&dis[v]>dis[u]+h[u]-h[v]+e[i].d) {
				dis[v]=dis[u]+h[u]-h[v]+e[i].d;
				pre[v]=i;
				flow[v]=min(flow[u],e[i].w);
				q.push(make_pair(dis[v],v));
			} 
		}
	}
	return dis[t]!=INF;
}
int main() {
	scanf("%d%d%d%d",&n,&m,&s,&t);
	memset(head,0xff,sizeof head);
	for(int i=1;i<=m;i++) {
		int u,v,w,c;
		scanf("%d%d%d%d",&u,&v,&w,&c);
		add(u,v,w,c);
		add(v,u,0,-c);
	}
	while(Dij(s,t)) {
		for(int i=1;i<=n;i++) h[i]+=dis[i];
		max_flow+=flow[t];min_cost+=flow[t]*h[t];
		int now=t;
		while(now!=s) {
			int i=pre[now];
			e[i].w-=flow[t];
			e[i^1].w+=flow[t];
			now=e[i^1].to;
		}
	}
	printf("%d %d",max_flow,min_cost);
	return 0;
}
```

zkw费用流，没有找到对于复杂度的严格说明，但貌似是比上述两者要快的

```cpp
#include<bits/stdc++.h>
using namespace std;
bool vis[200001];int dist[200001];
//解释一下各数组的含义：vis两个用处：spfa里的访问标记，増广时候的访问标记，dist是每个点的距离标号
int n,m,s,t,ans=0;
//s是起点，t是终点，ans是费用答案
int nedge=-1,p[200001],c[200001],cc[200001],nex[200001],head[200001];
//这里是边表，解释一下各数组的含义：p[i]表示以某一点出发的编号为i的边对应点，c表示编号为i的边的流量，cc表示编号为i的边的费用，nex和head不说了吧。。。
inline void addedge(int x,int y,int z,int zz){
    p[++nedge]=y;c[nedge]=z;cc[nedge]=zz;nex[nedge]=head[x];head[x]=nedge;
}
//建边（数组模拟边表倒挂）
inline bool spfa(int s,int t){
    memset(vis,0,sizeof vis);
    for(int i=0;i<=n;i++)dist[i]=1e9;dist[t]=0;vis[t]=1;
//首先SPFA我们维护距离标号的时候要倒着跑，这样可以维护出到终点的最短路径
    deque<int>q;q.push_back(t);
//使用了SPFA的SLF优化（SLF可以自行百度或Google）
    while(!q.empty()){
        int now=q.front();q.pop_front();
        for(int k=head[now];k>-1;k=nex[k])if(c[k^1]&&dist[p[k]]>dist[now]-cc[k]){
//首先c[k^1]是为什么呢，因为我们要保证正流，但是SPFA是倒着跑的，所以说我们要求c[k]的对应反向边是正的，这样保证走的方向是正确的
            dist[p[k]]=dist[now]-cc[k];
//因为已经是倒着的了，我们也可以很清楚明白地知道建边的时候反向边的边权是负的，所以减一下就对了（负负得正）
            if(!vis[p[k]]){
                vis[p[k]]=1;
                if(!q.empty()&&dist[p[k]]<dist[q.front()])q.push_front(p[k]);else q.push_back(p[k]);
//SLF优化
            }
        }
        vis[now]=0;
    }
    return dist[s]<1e9;
//判断起点终点是否连通
}
inline int dfs(int x,int low){
//这里就是进行増广了
    if(x==t){vis[t]=1;return low;}
    int used=0,a;vis[x]=1;
//这边是不是和dinic很像啊
    for(int k=head[x];k>-1;k=nex[k])if(!vis[p[k]]&&c[k]&&dist[x]-cc[k]==dist[p[k]]){
//这个条件就表示这条边可以进行増广
        a=dfs(p[k],min(c[k],low-used));
        if(a)ans+=a*cc[k],c[k]-=a,c[k^1]+=a,used+=a;
//累加答案，加流等操作都在这了
        if(used==low)break;
    }
    return used;
}
inline int costflow(){
    int flow=0;
    while(spfa(s,t)){
//判断起点终点是否连通，不连通说明满流，做完了退出
        vis[t]=1;
        while(vis[t]){
            memset(vis,0,sizeof vis);
            flow+=dfs(s,1e9);
//一直増广直到走不到为止（这样也可以省时间哦）
        }
    }
    return flow;//这里返回的是最大流，费用的答案在ans里
}
int main()
{
    memset(nex,-1,sizeof nex);memset(head,-1,sizeof head);
    scanf("%d%d%d%d",&n,&m,&s,&t);
    for(int i=1;i<=m;i++){
        int x,y,z,zz;scanf("%d%d%d%d",&x,&y,&z,&zz);
        addedge(x,y,z,zz);addedge(y,x,0,-zz);
    }
    printf("%d ",costflow());printf("%d",ans);
    return 0;
}
```



### 2-SAT

有 $n$ 个布尔变量 $x_1$$\sim$$x_n$，另有 $m$ 个需要满足的条件，每个条件的形式都是 「$x_i$ 为 `true` / `false` 或 $x_j$ 为 `true` / `false`」。比如 「$x_1$ 为真或 $x_3$ 为假」、「$x_7$ 为假或 $x_2$ 为假」

 $m$ 行每行 $4$ 个整数 $i$, $a$, $j$, $b$，表示 「$x_i$ 为 $a$ 或 $x_j$ 为 $b$」($a, b\in \{0,1\}$ 

如无解，输出 `IMPOSSIBLE`；否则输出 `POSSIBLE`

下一行 $n$ 个整数 $x_1\sim x_n$（$x_i\in\{0,1\}$），表示构造出的解

```cpp
//2-SAT:
//将每个数i的拆为i,i+n,分别表示i不选/选:可以得到一系列诸如A选B必选的限制条件 
//然后得到一个有向图,缩点之后,若i,i+n在一个强连通分量中则一定无解,
//反之一定有解,然后选择拓扑序大的决策点,因为大的对小的无影响 
//选小的有可能会推出来一定要选某个大的 
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e6+10;
int n,m,idx,cnt,head[maxn],dfn[maxn],low[maxn];
struct Edge{int to,next;} e[maxn];
inline void add(int u,int to) {e[++cnt].to=to;e[cnt].next=head[u];head[u]=cnt;}
int tot,id[maxn];
stack<int> s;
bool ins[maxn];
inline void tarjan(int u) {
    dfn[u]=low[u]=++idx;
    s.push(u);ins[u]=1;
    for(int i=head[u];i;i=e[i].next) {
        int v=e[i].to;
        if(!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]);
        else if(ins[v]) low[u]=min(low[u],dfn[v]);
    }
    if(low[u]==dfn[u]) {
		tot++;
        while(s.top()!=u) {
            id[s.top()]=tot;
            ins[s.top()]=0;
            s.pop();
        }
        id[s.top()]=tot;ins[s.top()]=0;s.pop(); 
    }
}
inline int gint() {//拙劣的非负快读（据说还有更快的）。 
    int ff=1,ee=0;char ss=getchar();
    while(ss<'0'||ss>'9') ss=getchar();
    while(ss>='0'&&ss<='9') {ee=(ee<<1)+(ee<<3)+(ss^48);ss=getchar();}
    return ee*ff;
}
int main() {
    n=gint();m=gint();
    for(int i=1,x,a,y,b;i<=m;i++) {
    	x=gint();a=gint();y=gint();b=gint();
    	add(x+(a^1)*n,y+b*n);add(y+(b^1)*n,x+a*n);
	}
    for(int i=1;i<=(n<<1);i++) if(!dfn[i]) tarjan(i);
    for(int i=1;i<=n;i++) if(id[i+n]==id[i]) {puts("IMPOSSIBLE");return 0;}
    puts("POSSIBLE");
    for(int i=1;i<=n;i++) {putchar(id[i+n]>id[i]?'0':'1');putchar(' ');}
	return 0;
}
```

### 差分约束系统

给定 $n$ 个不等式 $x_{u_i}-x_{v_i}\le w_i$ ，求满足该式的解

```cpp
#include<bits/stdc++.h> 
using namespace std;
struct edge {
	int v,w,next;
} e[10005];
int head[5005],tot[5005],dis[5005],vis[5005],cnt,n,m;
void addedge(int u,int v,int w) {
	e[++cnt].v=v;
	e[cnt].w=w;
	e[cnt].next=head[u];
	head[u]=cnt;
}
bool spfa(int s) {
	queue<int> q;
	memset(dis,63,sizeof(dis));
	dis[s]=0,vis[s]=1;
	q.push(s);
	while(!q.empty()) {
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=head[u];i;i=e[i].next) {
			int v=e[i].v;
			if(dis[v]>dis[u]+e[i].w) {
				dis[v]=dis[u]+e[i].w;
				if(!vis[v]) {
					vis[v]=1,tot[v]++;
					if(tot[v]==n+1)return false; // 注意添加了一个超级源点
					q.push(v);
				}
			}
		}
	}
	return true;
}
int main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++) addedge(0,i,0);
	for(int i=1;i<=m;i++) {
		int v,u,w;
		cin>>v>>u>>w;
		addedge(u,v,w);
	}
	if(!spfa(0)) cout<<"NO"<<endl;
	else for(int =1;i<=n;i++) cout<<dis[i]<<' ';
	return 0;
}
```

### 圆方树

处理仙人掌，将点双连通分量化为一个方点，初始点成为圆点，圆点向其所属于的点双连边

```cpp
#include <algorithm>
#include <cstdio>
#include <vector>

const int MN = 100005;

int N, M, cnt;
std::vector<int> G[MN], T[MN * 2];

int dfn[MN], low[MN], dfc;
int stk[MN], tp;

void Tarjan(int u) {
  printf("  Enter : #%d\n", u);
  low[u] = dfn[u] = ++dfc;                // low 初始化为当前节点 dfn
  stk[++tp] = u;                          // 加入栈中
  for (int v : G[u]) {                    // 遍历 u 的相邻节点
    if (!dfn[v]) {                        // 如果未访问过
      Tarjan(v);                          // 递归
      low[u] = std::min(low[u], low[v]);  // 未访问的和 low 取 min
      if (low[v] == dfn[u]) {  // 标志着找到一个以 u 为根的点双连通分量
        ++cnt;                 // 增加方点个数
        printf("  Found a New BCC #%d.\n", cnt - N);
        // 将点双中除了 u 的点退栈，并在圆方树中连边
        for (int x = 0; x != v; --tp) {
          x = stk[tp];
          T[cnt].push_back(x);
          T[x].push_back(cnt);
          printf("    BCC #%d has vertex #%d\n", cnt - N, x);
        }
        // 注意 u 自身也要连边（但不退栈）
        T[cnt].push_back(u);
        T[u].push_back(cnt);
        printf("    BCC #%d has vertex #%d\n", cnt - N, u);
      }
    } else
      low[u] = std::min(low[u], dfn[v]);  // 已访问的和 dfn 取 min
  }
  printf("  Exit : #%d : low = %d\n", u, low[u]);
  printf("  Stack:\n    ");
  for (int i = 1; i <= tp; ++i) printf("%d, ", stk[i]);
  puts("");
}

int main() {
  scanf("%d%d", &N, &M);
  cnt = N;  // 点双 / 方点标号从 N 开始
  for (int i = 1; i <= M; ++i) {
    int u, v;
    scanf("%d%d", &u, &v);
    G[u].push_back(v);  // 加双向边
    G[v].push_back(u);
  }
  // 处理非连通图
  for (int u = 1; u <= N; ++u)
    if (!dfn[u]) Tarjan(u), --tp;
  // 注意到退出 Tarjan 时栈中还有一个元素即根，将其退栈
  return 0;
}
```

### 欧拉路径（有向图）

此为求字典序最小的欧拉路径，使用时需注意判断图是否连通

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX=100010;
int n,m,u,v,del[MAX];
int du[MAX][2];//记录入度和出度 
stack <int> st;
vector <int> G[MAX];
void dfs(int now)
{
	for(int i=del[now];i<G[now].size();i=del[now])
	{ 
		del[now]=i+1;
		dfs(G[now][i]);
	}
	st.push(now);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++) scanf("%d%d",&u,&v),G[u].push_back(v),du[u][1]++,du[v][0]++;  
    for(int i=1;i<=n;i++) sort(G[i].begin(),G[i].end());
    int S=1,cnt[2]={0,0}; //记录
    bool flag=1; //flag=1表示,所有的节点的入度都等于出度,
    for(int i=1;i<=n;i++)
	{
        if(du[i][1]!=du[i][0])
        {
            flag=0;
            if(du[i][1]-du[i][0]==1/*出度比入度多1*/) cnt[1]++,S=i;
            else if(du[i][0]-du[i][1]==1/*入度比出度多1*/) cnt[0]++;
            else return puts("No"),0;
        }
    }
    if((!flag)&&!(cnt[0]==cnt[1]&&cnt[0]==1)) return !puts("No"),0;
    dfs(S);
    while(!st.empty()) printf("%d ",st.top()),st.pop();
    return 0; 
}
```

### 欧拉路径（无向图）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int n,m;
int deg[maxn],del[maxn];
vector<int> ans,p[maxn];
void dfs(int u){
    for(int i=del[u];i<p[u].size();i=del[u]){
        del[u]++;
        del[p[u][i]]++;
        dfs(p[u][i]);
    }
    ans.push_back(u);
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>m;
    for(int i=1,u,v;i<=m;i++){
        cin>>u>>v;
        p[u].push_back(v);
        p[v].push_back(u);
        deg[v]++,deg[u]++;
    }
    int st=0,ff=1;
    int cnt=0;
    for(int i=1;i<=n;i++){
        if(deg[i]%2==1) ff=0;
        else{
        	cnt++;
        	if(!st) st=i;
		}
    }
    if(!st) for(int i=1;i<=n;i++){
    	if(deg[i]){
    		st=i;
    		break;
		}
	}
    if(ff!=1&&cnt!=0&&cnt!=2){
        cout<<"No";
        return 0;
    }
    dfs(st);
    reverse(ans.begin(),ans.end());
    for(auto u:ans) cout<<u<<' ';
    return 0;
}
```

